using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Mpeg4Lib.Boxes
{
	public class MoovBox : Box
	{
		public MoovBox(Stream file, BoxHeader header) : base(header, null)
		{
			LoadChildren(file);
		}

		public MvhdBox Mvhd => GetChildOrThrow<MvhdBox>();
		public TrakBox AudioTrack => Tracks.Where(t => t.GetChild<MdiaBox>()?.GetChild<HdlrBox>()?.HandlerType == "soun").First();
		public TrakBox? VideoTrack => Tracks.Where(t => t.GetChild<MdiaBox>()?.GetChild<HdlrBox>()?.HandlerType == "vide").FirstOrDefault();
		public TrakBox? TextTrack => Tracks.Where(t => t.GetChild<MdiaBox>()?.GetChild<HdlrBox>()?.HandlerType == "text").FirstOrDefault();
		public AppleListBox? ILst => GetChild<UdtaBox>()?.GetChild<MetaBox>()?.GetChild<AppleListBox>();
		public IEnumerable<TrakBox> Tracks => GetChildren<TrakBox>();

		/// <summary>
		/// Adjust the chunk offsets in all tracks
		/// </summary>
		/// <param name="shiftVector">The size and direction of the shift</param>
		public void ShiftChunkOffsets(long shiftVector)
		{
			foreach (var track in Tracks)
			{
				var coBox = track.Mdia.Minf.Stbl.COBox.ChunkOffsets;
				for (int i = 0; i < coBox.Count; i++)
				{
					var offset = coBox.GetOffsetAtIndex(i);
					coBox.SetOffsetAtIndex(i, offset + shiftVector);
				}
			}
		}

		public AppleListBox CreateEmptyMetadata()
		{
			if (ILst is AppleListBox ilist)
			{
				return ilist;
			}
			else
			{
				var udata = UdtaBox.CreateEmpty(this);
				var meta = MetaBox.CreateEmpty(udata);
				var hdlr = HdlrBox.Create("mdir", null, [0x61, 0x70, 0x70, 0x6c], meta);
				return AppleListBox.CreateEmpty(meta);
			}
		}

		public TrakBox CreateEmptyTextTrack()
		{
			if (TextTrack is TrakBox txt)
			{
				return txt;
			}
			else
			{
				using var ms = new MemoryStream(EmptyTextTrack);
				var textTrack = BoxFactory.CreateBox<TrakBox>(ms, null);
				Children.Insert(Children.IndexOf(AudioTrack) + 1, textTrack);

				textTrack.Tkhd.TrackID = Mvhd.NextTrackID++;

				HashSet<uint> references
					= GetChildren<TrakBox>()
					.Except([AudioTrack])
					.Select(t => t.Tkhd.TrackID)
					.Order()
					.ToHashSet();

				if (AudioTrack.GetChild<TrefBox>() is TrefBox tref)
				{
					if (tref.References.FirstOrDefault(r => r.Header.Type == "chap") is ITrackReferenceTypeBox referenceType)
						referenceType.TrackIds = references;
					else
						tref.AddReference("chap", references);
				}
				else
					TrefBox.CreatEmpty(AudioTrack).AddReference("chap", references);

				textTrack.Tkhd.CreationTime = textTrack.Tkhd.ModificationTime = textTrack.Mdia.Mdhd.CreationTime = textTrack.Mdia.Mdhd.ModificationTime = DateTimeOffset.UtcNow;
				textTrack.Mdia.Mdhd.Timescale = AudioTrack.Mdia.Mdhd.Timescale;
				return textTrack;
			}
		}

		private static readonly byte[] EmptyTextTrack = [0x00, 0x00, 0x02, 0x11, 0x74, 0x72, 0x61, 0x6b, 0x00, 0x00, 0x00, 0x5c, 0x74, 0x6b, 0x68, 0x64, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x01, 0x70, 0x6d, 0x64, 0x69, 0x61, 0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x68, 0x64, 0x6c, 0x72, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x68, 0x6c, 0x72, 0x74, 0x65, 0x78, 0x74, 0x61, 0x70, 0x70, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20, 0x54, 0x65, 0x78, 0x74, 0x20, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x20, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x01, 0x0f, 0x6d, 0x69, 0x6e, 0x66, 0x00, 0x00, 0x00, 0x4c, 0x67, 0x6d, 0x68, 0x64, 0x00, 0x00, 0x00, 0x18, 0x67, 0x6d, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x64, 0x69, 0x6e, 0x66, 0x00, 0x00, 0x00, 0x1c, 0x64, 0x72, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c, 0x61, 0x6c, 0x69, 0x73, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x97, 0x73, 0x74, 0x62, 0x6c, 0x00, 0x00, 0x00, 0x4b, 0x73, 0x74, 0x73, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3b, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x74, 0x63, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x73, 0x74, 0x73, 0x7a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x75, 0x64, 0x74, 0x61, 0x00, 0x00, 0x00, 0x35, 0x6d, 0x65, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x68, 0x64, 0x6c, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x64, 0x69, 0x72, 0x61, 0x70, 0x70, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x69, 0x6c, 0x73, 0x74];

		protected override void Render(Stream file)
		{
			return;
		}
	}
}
