// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: license_protocol.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace AAXClean.Widevine.Provisioning {

  /// <summary>Holder for reflection information generated from license_protocol.proto</summary>
  public static partial class LicenseProtocolReflection {

    #region Descriptor
    /// <summary>File descriptor for license_protocol.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LicenseProtocolReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZsaWNlbnNlX3Byb3RvY29sLnByb3RvEh5BQVhDbGVhbi5XaWRldmluZS5Q",
            "cm92aXNpb25pbmciwAEKFUxpY2Vuc2VJZGVudGlmaWNhdGlvbhISCgpyZXF1",
            "ZXN0X2lkGAEgASgMEhIKCnNlc3Npb25faWQYAiABKAwSEwoLcHVyY2hhc2Vf",
            "aWQYAyABKAwSOQoEdHlwZRgEIAEoDjIrLkFBWENsZWFuLldpZGV2aW5lLlBy",
            "b3Zpc2lvbmluZy5MaWNlbnNlVHlwZRIPCgd2ZXJzaW9uGAUgASgFEh4KFnBy",
            "b3ZpZGVyX3Nlc3Npb25fdG9rZW4YBiABKAwi8xMKB0xpY2Vuc2USQQoCaWQY",
            "ASABKAsyNS5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuTGljZW5z",
            "ZUlkZW50aWZpY2F0aW9uEj4KBnBvbGljeRgCIAEoCzIuLkFBWENsZWFuLldp",
            "ZGV2aW5lLlByb3Zpc2lvbmluZy5MaWNlbnNlLlBvbGljeRJBCgNrZXkYAyAD",
            "KAsyNC5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuTGljZW5zZS5L",
            "ZXlDb250YWluZXISGgoSbGljZW5zZV9zdGFydF90aW1lGAQgASgDEioKG3Jl",
            "bW90ZV9hdHRlc3RhdGlvbl92ZXJpZmllZBgFIAEoCDoFZmFsc2USHQoVcHJv",
            "dmlkZXJfY2xpZW50X3Rva2VuGAYgASgMGqMDCgZQb2xpY3kSFwoIY2FuX3Bs",
            "YXkYASABKAg6BWZhbHNlEhoKC2Nhbl9wZXJzaXN0GAIgASgIOgVmYWxzZRIY",
            "CgljYW5fcmVuZXcYAyABKAg6BWZhbHNlEiIKF3JlbnRhbF9kdXJhdGlvbl9z",
            "ZWNvbmRzGAQgASgDOgEwEiQKGXBsYXliYWNrX2R1cmF0aW9uX3NlY29uZHMY",
            "BSABKAM6ATASIwoYbGljZW5zZV9kdXJhdGlvbl9zZWNvbmRzGAYgASgDOgEw",
            "EiwKIXJlbmV3YWxfcmVjb3ZlcnlfZHVyYXRpb25fc2Vjb25kcxgHIAEoAzoB",
            "MBIaChJyZW5ld2FsX3NlcnZlcl91cmwYCCABKAkSIAoVcmVuZXdhbF9kZWxh",
            "eV9zZWNvbmRzGAkgASgDOgEwEikKHnJlbmV3YWxfcmV0cnlfaW50ZXJ2YWxf",
            "c2Vjb25kcxgKIAEoAzoBMBIfChByZW5ld193aXRoX3VzYWdlGAsgASgIOgVm",
            "YWxzZRIjChRyZW5ld193aXRoX2NsaWVudF9pZBgMIAEoCDoFZmFsc2UalA4K",
            "DEtleUNvbnRhaW5lchIKCgJpZBgBIAEoDBIKCgJpdhgCIAEoDBILCgNrZXkY",
            "AyABKAwSSgoEdHlwZRgEIAEoDjI8LkFBWENsZWFuLldpZGV2aW5lLlByb3Zp",
            "c2lvbmluZy5MaWNlbnNlLktleUNvbnRhaW5lci5LZXlUeXBlEmMKBWxldmVs",
            "GAUgASgOMkIuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vu",
            "c2UuS2V5Q29udGFpbmVyLlNlY3VyaXR5TGV2ZWw6EFNXX1NFQ1VSRV9DUllQ",
            "VE8SYgoTcmVxdWlyZWRfcHJvdGVjdGlvbhgGIAEoCzJFLkFBWENsZWFuLldp",
            "ZGV2aW5lLlByb3Zpc2lvbmluZy5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRw",
            "dXRQcm90ZWN0aW9uEmMKFHJlcXVlc3RlZF9wcm90ZWN0aW9uGAcgASgLMkUu",
            "QUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2UuS2V5Q29u",
            "dGFpbmVyLk91dHB1dFByb3RlY3Rpb24SVAoLa2V5X2NvbnRyb2wYCCABKAsy",
            "Py5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuTGljZW5zZS5LZXlD",
            "b250YWluZXIuS2V5Q29udHJvbBJ8CiBvcGVyYXRvcl9zZXNzaW9uX2tleV9w",
            "ZXJtaXNzaW9ucxgJIAEoCzJSLkFBWENsZWFuLldpZGV2aW5lLlByb3Zpc2lv",
            "bmluZy5MaWNlbnNlLktleUNvbnRhaW5lci5PcGVyYXRvclNlc3Npb25LZXlQ",
            "ZXJtaXNzaW9ucxJ0Chx2aWRlb19yZXNvbHV0aW9uX2NvbnN0cmFpbnRzGAog",
            "AygLMk4uQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2Uu",
            "S2V5Q29udGFpbmVyLlZpZGVvUmVzb2x1dGlvbkNvbnN0cmFpbnQSKAoZYW50",
            "aV9yb2xsYmFja191c2FnZV90YWJsZRgLIAEoCDoFZmFsc2UaMwoKS2V5Q29u",
            "dHJvbBIZChFrZXlfY29udHJvbF9ibG9jaxgBIAEoDBIKCgJpdhgCIAEoDBqT",
            "AwoQT3V0cHV0UHJvdGVjdGlvbhJjCgRoZGNwGAEgASgOMkouQUFYQ2xlYW4u",
            "V2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91",
            "dHB1dFByb3RlY3Rpb24uSERDUDoJSERDUF9OT05FEmkKCmNnbXNfZmxhZ3MY",
            "AiABKA4ySi5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuTGljZW5z",
            "ZS5LZXlDb250YWluZXIuT3V0cHV0UHJvdGVjdGlvbi5DR01TOglDR01TX05P",
            "TkUiagoESERDUBINCglIRENQX05PTkUQABILCgdIRENQX1YxEAESCwoHSERD",
            "UF9WMhACEg0KCUhEQ1BfVjJfMRADEg0KCUhEQ1BfVjJfMhAEEhsKFkhEQ1Bf",
            "Tk9fRElHSVRBTF9PVVRQVVQQ/wEiQwoEQ0dNUxINCglDR01TX05PTkUQKhIN",
            "CglDT1BZX0ZSRUUQABINCglDT1BZX09OQ0UQAhIOCgpDT1BZX05FVkVSEAMa",
            "vQEKGVZpZGVvUmVzb2x1dGlvbkNvbnN0cmFpbnQSHQoVbWluX3Jlc29sdXRp",
            "b25fcGl4ZWxzGAEgASgNEh0KFW1heF9yZXNvbHV0aW9uX3BpeGVscxgCIAEo",
            "DRJiChNyZXF1aXJlZF9wcm90ZWN0aW9uGAMgASgLMkUuQUFYQ2xlYW4uV2lk",
            "ZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1",
            "dFByb3RlY3Rpb24anQEKHU9wZXJhdG9yU2Vzc2lvbktleVBlcm1pc3Npb25z",
            "EhwKDWFsbG93X2VuY3J5cHQYASABKAg6BWZhbHNlEhwKDWFsbG93X2RlY3J5",
            "cHQYAiABKAg6BWZhbHNlEhkKCmFsbG93X3NpZ24YAyABKAg6BWZhbHNlEiUK",
            "FmFsbG93X3NpZ25hdHVyZV92ZXJpZnkYBCABKAg6BWZhbHNlIkoKB0tleVR5",
            "cGUSCwoHU0lHTklORxABEgsKB0NPTlRFTlQQAhIPCgtLRVlfQ09OVFJPTBAD",
            "EhQKEE9QRVJBVE9SX1NFU1NJT04QBCJ6Cg1TZWN1cml0eUxldmVsEhQKEFNX",
            "X1NFQ1VSRV9DUllQVE8QARIUChBTV19TRUNVUkVfREVDT0RFEAISFAoQSFdf",
            "U0VDVVJFX0NSWVBUTxADEhQKEEhXX1NFQ1VSRV9ERUNPREUQBBIRCg1IV19T",
            "RUNVUkVfQUxMEAUikwoKDkxpY2Vuc2VSZXF1ZXN0EkcKCWNsaWVudF9pZBgB",
            "IAEoCzI0LkFBWENsZWFuLldpZGV2aW5lLlByb3Zpc2lvbmluZy5DbGllbnRJ",
            "ZGVudGlmaWNhdGlvbhJYCgpjb250ZW50X2lkGAIgASgLMkQuQUFYQ2xlYW4u",
            "V2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJ",
            "ZGVudGlmaWNhdGlvbhJICgR0eXBlGAMgASgOMjouQUFYQ2xlYW4uV2lkZXZp",
            "bmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VSZXF1ZXN0LlJlcXVlc3RUeXBlEhQK",
            "DHJlcXVlc3RfdGltZRgEIAEoAxIkChxrZXlfY29udHJvbF9ub25jZV9kZXBy",
            "ZWNhdGVkGAUgASgMElYKEHByb3RvY29sX3ZlcnNpb24YBiABKA4yLy5BQVhD",
            "bGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuUHJvdG9jb2xWZXJzaW9uOgtW",
            "RVJTSU9OXzJfMBIZChFrZXlfY29udHJvbF9ub25jZRgHIAEoDRJaChNlbmNy",
            "eXB0ZWRfY2xpZW50X2lkGAggASgLMj0uQUFYQ2xlYW4uV2lkZXZpbmUuUHJv",
            "dmlzaW9uaW5nLkVuY3J5cHRlZENsaWVudElkZW50aWZpY2F0aW9uGtYFChVD",
            "b250ZW50SWRlbnRpZmljYXRpb24SWgoHY2VuY19pZBgBIAEoCzJJLkFBWENs",
            "ZWFuLldpZGV2aW5lLlByb3Zpc2lvbmluZy5MaWNlbnNlUmVxdWVzdC5Db250",
            "ZW50SWRlbnRpZmljYXRpb24uQ0VOQxJaCgd3ZWJtX2lkGAIgASgLMkkuQUFY",
            "Q2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VSZXF1ZXN0LkNv",
            "bnRlbnRJZGVudGlmaWNhdGlvbi5XZWJNEmUKB2xpY2Vuc2UYAyABKAsyVC5B",
            "QVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuTGljZW5zZVJlcXVlc3Qu",
            "Q29udGVudElkZW50aWZpY2F0aW9uLkV4aXN0aW5nTGljZW5zZRprCgRDRU5D",
            "EgwKBHBzc2gYASADKAwSQQoMbGljZW5zZV90eXBlGAIgASgOMisuQUFYQ2xl",
            "YW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VUeXBlEhIKCnJlcXVl",
            "c3RfaWQYAyABKAwabQoEV2ViTRIOCgZoZWFkZXIYASABKAwSQQoMbGljZW5z",
            "ZV90eXBlGAIgASgOMisuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5n",
            "LkxpY2Vuc2VUeXBlEhIKCnJlcXVlc3RfaWQYAyABKAwawQEKD0V4aXN0aW5n",
            "TGljZW5zZRJJCgpsaWNlbnNlX2lkGAEgASgLMjUuQUFYQ2xlYW4uV2lkZXZp",
            "bmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VJZGVudGlmaWNhdGlvbhIdChVzZWNv",
            "bmRzX3NpbmNlX3N0YXJ0ZWQYAiABKAMSIQoZc2Vjb25kc19zaW5jZV9sYXN0",
            "X3BsYXllZBgDIAEoAxIhChlzZXNzaW9uX3VzYWdlX3RhYmxlX2VudHJ5GAQg",
            "ASgMIjAKC1JlcXVlc3RUeXBlEgcKA05FVxABEgsKB1JFTkVXQUwQAhILCgdS",
            "RUxFQVNFEAMiuAEKDExpY2Vuc2VFcnJvchJGCgplcnJvcl9jb2RlGAEgASgO",
            "MjIuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkxpY2Vuc2VFcnJv",
            "ci5FcnJvciJgCgVFcnJvchIeChpJTlZBTElEX0RFVklDRV9DRVJUSUZJQ0FU",
            "RRABEh4KGlJFVk9LRURfREVWSUNFX0NFUlRJRklDQVRFEAISFwoTU0VSVklD",
            "RV9VTkFWQUlMQUJMRRADIogBChFSZW1vdGVBdHRlc3RhdGlvbhJSCgtjZXJ0",
            "aWZpY2F0ZRgBIAEoCzI9LkFBWENsZWFuLldpZGV2aW5lLlByb3Zpc2lvbmlu",
            "Zy5FbmNyeXB0ZWRDbGllbnRJZGVudGlmaWNhdGlvbhIMCgRzYWx0GAIgASgM",
            "EhEKCXNpZ25hdHVyZRgDIAEoDCLbAgoNU2lnbmVkTWVzc2FnZRJHCgR0eXBl",
            "GAEgASgOMjkuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLlNpZ25l",
            "ZE1lc3NhZ2UuTWVzc2FnZVR5cGUSCwoDbXNnGAIgASgMEhEKCXNpZ25hdHVy",
            "ZRgDIAEoDBITCgtzZXNzaW9uX2tleRgEIAEoDBJNChJyZW1vdGVfYXR0ZXN0",
            "YXRpb24YBSABKAsyMS5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcu",
            "UmVtb3RlQXR0ZXN0YXRpb24ifQoLTWVzc2FnZVR5cGUSEwoPTElDRU5TRV9S",
            "RVFVRVNUEAESCwoHTElDRU5TRRACEhIKDkVSUk9SX1JFU1BPTlNFEAMSHwob",
            "U0VSVklDRV9DRVJUSUZJQ0FURV9SRVFVRVNUEAQSFwoTU0VSVklDRV9DRVJU",
            "SUZJQ0FURRAFIsIBChNQcm92aXNpb25pbmdPcHRpb25zEl0KEGNlcnRpZmlj",
            "YXRlX3R5cGUYASABKA4yQy5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25p",
            "bmcuUHJvdmlzaW9uaW5nT3B0aW9ucy5DZXJ0aWZpY2F0ZVR5cGUSHQoVY2Vy",
            "dGlmaWNhdGVfYXV0aG9yaXR5GAIgASgJIi0KD0NlcnRpZmljYXRlVHlwZRIQ",
            "CgxXSURFVklORV9EUk0QABIICgRYNTA5EAEixgEKE1Byb3Zpc2lvbmluZ1Jl",
            "cXVlc3QSRwoJY2xpZW50X2lkGAEgASgLMjQuQUFYQ2xlYW4uV2lkZXZpbmUu",
            "UHJvdmlzaW9uaW5nLkNsaWVudElkZW50aWZpY2F0aW9uEg0KBW5vbmNlGAIg",
            "ASgMEkQKB29wdGlvbnMYAyABKAsyMy5BQVhDbGVhbi5XaWRldmluZS5Qcm92",
            "aXNpb25pbmcuUHJvdmlzaW9uaW5nT3B0aW9ucxIRCglzdGFibGVfaWQYBCAB",
            "KAwidAoUUHJvdmlzaW9uaW5nUmVzcG9uc2USFgoOZGV2aWNlX3JzYV9rZXkY",
            "ASABKAwSGQoRZGV2aWNlX3JzYV9rZXlfaXYYAiABKAwSGgoSZGV2aWNlX2Nl",
            "cnRpZmljYXRlGAMgASgMEg0KBW5vbmNlGAQgASgMIj8KGVNpZ25lZFByb3Zp",
            "c2lvbmluZ01lc3NhZ2USDwoHbWVzc2FnZRgBIAEoDBIRCglzaWduYXR1cmUY",
            "AiABKAwiowcKFENsaWVudElkZW50aWZpY2F0aW9uElQKBHR5cGUYASABKA4y",
            "Pi5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNpb25pbmcuQ2xpZW50SWRlbnRp",
            "ZmljYXRpb24uVG9rZW5UeXBlOgZLRVlCT1gSDQoFdG9rZW4YAiABKAwSUwoL",
            "Y2xpZW50X2luZm8YAyADKAsyPi5BQVhDbGVhbi5XaWRldmluZS5Qcm92aXNp",
            "b25pbmcuQ2xpZW50SWRlbnRpZmljYXRpb24uTmFtZVZhbHVlEh0KFXByb3Zp",
            "ZGVyX2NsaWVudF90b2tlbhgEIAEoDBIXCg9saWNlbnNlX2NvdW50ZXIYBSAB",
            "KA0SZAoTY2xpZW50X2NhcGFiaWxpdGllcxgGIAEoCzJHLkFBWENsZWFuLldp",
            "ZGV2aW5lLlByb3Zpc2lvbmluZy5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGll",
            "bnRDYXBhYmlsaXRpZXMaKAoJTmFtZVZhbHVlEgwKBG5hbWUYASABKAkSDQoF",
            "dmFsdWUYAiABKAkaswMKEkNsaWVudENhcGFiaWxpdGllcxIbCgxjbGllbnRf",
            "dG9rZW4YASABKAg6BWZhbHNlEhwKDXNlc3Npb25fdG9rZW4YAiABKAg6BWZh",
            "bHNlEisKHHZpZGVvX3Jlc29sdXRpb25fY29uc3RyYWludHMYAyABKAg6BWZh",
            "bHNlEngKEG1heF9oZGNwX3ZlcnNpb24YBCABKA4yUy5BQVhDbGVhbi5XaWRl",
            "dmluZS5Qcm92aXNpb25pbmcuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50",
            "Q2FwYWJpbGl0aWVzLkhkY3BWZXJzaW9uOglIRENQX05PTkUSHgoWb2VtX2Ny",
            "eXB0b19hcGlfdmVyc2lvbhgFIAEoDRIoChlhbnRpX3JvbGxiYWNrX3VzYWdl",
            "X3RhYmxlGAYgASgIOgVmYWxzZSJxCgtIZGNwVmVyc2lvbhINCglIRENQX05P",
            "TkUQABILCgdIRENQX1YxEAESCwoHSERDUF9WMhACEg0KCUhEQ1BfVjJfMRAD",
            "Eg0KCUhEQ1BfVjJfMhAEEhsKFkhEQ1BfTk9fRElHSVRBTF9PVVRQVVQQ/wEi",
            "UwoJVG9rZW5UeXBlEgoKBktFWUJPWBAAEhYKEkRFVklDRV9DRVJUSUZJQ0FU",
            "RRABEiIKHlJFTU9URV9BVFRFU1RBVElPTl9DRVJUSUZJQ0FURRACIroBCh1F",
            "bmNyeXB0ZWRDbGllbnRJZGVudGlmaWNhdGlvbhISCgpzZXJ2aWNlX2lkGAEg",
            "ASgJEikKIXNlcnZpY2VfY2VydGlmaWNhdGVfc2VyaWFsX251bWJlchgCIAEo",
            "DBIbChNlbmNyeXB0ZWRfY2xpZW50X2lkGAMgASgMEh4KFmVuY3J5cHRlZF9j",
            "bGllbnRfaWRfaXYYBCABKAwSHQoVZW5jcnlwdGVkX3ByaXZhY3lfa2V5GAUg",
            "ASgMIsYCChFEZXZpY2VDZXJ0aWZpY2F0ZRJPCgR0eXBlGAEgASgOMkEuQUFY",
            "Q2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkRldmljZUNlcnRpZmljYXRl",
            "LkNlcnRpZmljYXRlVHlwZRIVCg1zZXJpYWxfbnVtYmVyGAIgASgMEh0KFWNy",
            "ZWF0aW9uX3RpbWVfc2Vjb25kcxgDIAEoDRISCgpwdWJsaWNfa2V5GAQgASgM",
            "EhEKCXN5c3RlbV9pZBgFIAEoDRIiChZ0ZXN0X2RldmljZV9kZXByZWNhdGVk",
            "GAYgASgIQgIYARISCgpzZXJ2aWNlX2lkGAcgASgJIksKD0NlcnRpZmljYXRl",
            "VHlwZRIICgRST09UEAASEAoMSU5URVJNRURJQVRFEAESDwoLVVNFUl9ERVZJ",
            "Q0UQAhILCgdTRVJWSUNFEAMikQEKF1NpZ25lZERldmljZUNlcnRpZmljYXRl",
            "EhoKEmRldmljZV9jZXJ0aWZpY2F0ZRgBIAEoDBIRCglzaWduYXR1cmUYAiAB",
            "KAwSRwoGc2lnbmVyGAMgASgLMjcuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlz",
            "aW9uaW5nLlNpZ25lZERldmljZUNlcnRpZmljYXRlIuQCChVQcm92aXNpb25l",
            "ZERldmljZUluZm8SEQoJc3lzdGVtX2lkGAEgASgNEgsKA3NvYxgCIAEoCRIU",
            "CgxtYW51ZmFjdHVyZXIYAyABKAkSDQoFbW9kZWwYBCABKAkSEwoLZGV2aWNl",
            "X3R5cGUYBSABKAkSEgoKbW9kZWxfeWVhchgGIAEoDRJwCg5zZWN1cml0eV9s",
            "ZXZlbBgHIAEoDjJFLkFBWENsZWFuLldpZGV2aW5lLlByb3Zpc2lvbmluZy5Q",
            "cm92aXNpb25lZERldmljZUluZm8uV3ZTZWN1cml0eUxldmVsOhFMRVZFTF9V",
            "TlNQRUNJRklFRBIaCgt0ZXN0X2RldmljZRgIIAEoCDoFZmFsc2UiTwoPV3ZT",
            "ZWN1cml0eUxldmVsEhUKEUxFVkVMX1VOU1BFQ0lGSUVEEAASCwoHTEVWRUxf",
            "MRABEgsKB0xFVkVMXzIQAhILCgdMRVZFTF8zEAMiiwIKF0RldmljZUNlcnRp",
            "ZmljYXRlU3RhdHVzEhUKDXNlcmlhbF9udW1iZXIYASABKAwSYAoGc3RhdHVz",
            "GAIgASgOMkkuQUFYQ2xlYW4uV2lkZXZpbmUuUHJvdmlzaW9uaW5nLkRldmlj",
            "ZUNlcnRpZmljYXRlU3RhdHVzLkNlcnRpZmljYXRlU3RhdHVzOgVWQUxJRBJK",
            "CgtkZXZpY2VfaW5mbxgEIAEoCzI1LkFBWENsZWFuLldpZGV2aW5lLlByb3Zp",
            "c2lvbmluZy5Qcm92aXNpb25lZERldmljZUluZm8iKwoRQ2VydGlmaWNhdGVT",
            "dGF0dXMSCQoFVkFMSUQQABILCgdSRVZPS0VEEAEikQEKG0RldmljZUNlcnRp",
            "ZmljYXRlU3RhdHVzTGlzdBIdChVjcmVhdGlvbl90aW1lX3NlY29uZHMYASAB",
            "KA0SUwoSY2VydGlmaWNhdGVfc3RhdHVzGAIgAygLMjcuQUFYQ2xlYW4uV2lk",
            "ZXZpbmUuUHJvdmlzaW9uaW5nLkRldmljZUNlcnRpZmljYXRlU3RhdHVzIlEK",
            "G1NpZ25lZENlcnRpZmljYXRlU3RhdHVzTGlzdBIfChdjZXJ0aWZpY2F0ZV9z",
            "dGF0dXNfbGlzdBgBIAEoDBIRCglzaWduYXR1cmUYAiABKAwqKQoLTGljZW5z",
            "ZVR5cGUSDQoJU1RSRUFNSU5HEAESCwoHT0ZGTElORRACKjMKD1Byb3RvY29s",
            "VmVyc2lvbhIPCgtWRVJTSU9OXzJfMBAUEg8KC1ZFUlNJT05fMl8xEBVCAkgD"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::AAXClean.Widevine.Provisioning.LicenseType), typeof(global::AAXClean.Widevine.Provisioning.ProtocolVersion), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseIdentification), global::AAXClean.Widevine.Provisioning.LicenseIdentification.Parser, new[]{ "RequestId", "SessionId", "PurchaseId", "Type", "Version", "ProviderSessionToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License), global::AAXClean.Widevine.Provisioning.License.Parser, new[]{ "Id", "Policy", "Key", "LicenseStartTime", "RemoteAttestationVerified", "ProviderClientToken" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.Policy), global::AAXClean.Widevine.Provisioning.License.Types.Policy.Parser, new[]{ "CanPlay", "CanPersist", "CanRenew", "RentalDurationSeconds", "PlaybackDurationSeconds", "LicenseDurationSeconds", "RenewalRecoveryDurationSeconds", "RenewalServerUrl", "RenewalDelaySeconds", "RenewalRetryIntervalSeconds", "RenewWithUsage", "RenewWithClientId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer), global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Parser, new[]{ "Id", "Iv", "Key", "Type", "Level", "RequiredProtection", "RequestedProtection", "KeyControl", "OperatorSessionKeyPermissions", "VideoResolutionConstraints", "AntiRollbackUsageTable" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType), typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl), global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl.Parser, new[]{ "KeyControlBlock", "Iv" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection), global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Parser, new[]{ "Hdcp", "CgmsFlags" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP), typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint), global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint.Parser, new[]{ "MinResolutionPixels", "MaxResolutionPixels", "RequiredProtection" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions), global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions.Parser, new[]{ "AllowEncrypt", "AllowDecrypt", "AllowSign", "AllowSignatureVerify" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest), global::AAXClean.Widevine.Provisioning.LicenseRequest.Parser, new[]{ "ClientId", "ContentId", "Type", "RequestTime", "KeyControlNonceDeprecated", "ProtocolVersion", "KeyControlNonce", "EncryptedClientId" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification), global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Parser, new[]{ "CencId", "WebmId", "License" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC), global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC.Parser, new[]{ "Pssh", "LicenseType", "RequestId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM), global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM.Parser, new[]{ "Header", "LicenseType", "RequestId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense), global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense.Parser, new[]{ "LicenseId", "SecondsSinceStarted", "SecondsSinceLastPlayed", "SessionUsageTableEntry" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.LicenseError), global::AAXClean.Widevine.Provisioning.LicenseError.Parser, new[]{ "ErrorCode" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.RemoteAttestation), global::AAXClean.Widevine.Provisioning.RemoteAttestation.Parser, new[]{ "Certificate", "Salt", "Signature" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.SignedMessage), global::AAXClean.Widevine.Provisioning.SignedMessage.Parser, new[]{ "Type", "Msg", "Signature", "SessionKey", "RemoteAttestation" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ProvisioningOptions), global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Parser, new[]{ "CertificateType", "CertificateAuthority" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ProvisioningRequest), global::AAXClean.Widevine.Provisioning.ProvisioningRequest.Parser, new[]{ "ClientId", "Nonce", "Options", "StableId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ProvisioningResponse), global::AAXClean.Widevine.Provisioning.ProvisioningResponse.Parser, new[]{ "DeviceRsaKey", "DeviceRsaKeyIv", "DeviceCertificate", "Nonce" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.SignedProvisioningMessage), global::AAXClean.Widevine.Provisioning.SignedProvisioningMessage.Parser, new[]{ "Message", "Signature" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ClientIdentification), global::AAXClean.Widevine.Provisioning.ClientIdentification.Parser, new[]{ "Type", "Token", "ClientInfo", "ProviderClientToken", "LicenseCounter", "ClientCapabilities" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue), global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue.Parser, new[]{ "Name", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities), global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Parser, new[]{ "ClientToken", "SessionToken", "VideoResolutionConstraints", "MaxHdcpVersion", "OemCryptoApiVersion", "AntiRollbackUsageTable" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification), global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification.Parser, new[]{ "ServiceId", "ServiceCertificateSerialNumber", "EncryptedClientId", "EncryptedClientIdIv", "EncryptedPrivacyKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.DeviceCertificate), global::AAXClean.Widevine.Provisioning.DeviceCertificate.Parser, new[]{ "Type", "SerialNumber", "CreationTimeSeconds", "PublicKey", "SystemId", "TestDeviceDeprecated", "ServiceId" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate), global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate.Parser, new[]{ "DeviceCertificate", "Signature", "Signer" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo), global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Parser, new[]{ "SystemId", "Soc", "Manufacturer", "Model", "DeviceType", "ModelYear", "SecurityLevel", "TestDevice" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus), global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Parser, new[]{ "SerialNumber", "Status", "DeviceInfo" }, null, new[]{ typeof(global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.DeviceCertificateStatusList), global::AAXClean.Widevine.Provisioning.DeviceCertificateStatusList.Parser, new[]{ "CreationTimeSeconds", "CertificateStatus" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AAXClean.Widevine.Provisioning.SignedCertificateStatusList), global::AAXClean.Widevine.Provisioning.SignedCertificateStatusList.Parser, new[]{ "CertificateStatusList", "Signature" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum LicenseType {
    [pbr::OriginalName("STREAMING")] Streaming = 1,
    [pbr::OriginalName("OFFLINE")] Offline = 2,
  }

  public enum ProtocolVersion {
    [pbr::OriginalName("VERSION_2_0")] Version20 = 20,
    [pbr::OriginalName("VERSION_2_1")] Version21 = 21,
  }

  #endregion

  #region Messages
  /// <summary>
  /// LicenseIdentification is propagated from LicenseRequest to License,
  /// incrementing version with each iteration.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LicenseIdentification : pb::IMessage<LicenseIdentification>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicenseIdentification> _parser = new pb::MessageParser<LicenseIdentification>(() => new LicenseIdentification());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicenseIdentification> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseIdentification() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseIdentification(LicenseIdentification other) : this() {
      _hasBits0 = other._hasBits0;
      requestId_ = other.requestId_;
      sessionId_ = other.sessionId_;
      purchaseId_ = other.purchaseId_;
      type_ = other.type_;
      version_ = other.version_;
      providerSessionToken_ = other.providerSessionToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseIdentification Clone() {
      return new LicenseIdentification(this);
    }

    /// <summary>Field number for the "request_id" field.</summary>
    public const int RequestIdFieldNumber = 1;
    private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString requestId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString RequestId {
      get { return requestId_ ?? RequestIdDefaultValue; }
      set {
        requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "request_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRequestId {
      get { return requestId_ != null; }
    }
    /// <summary>Clears the value of the "request_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRequestId() {
      requestId_ = null;
    }

    /// <summary>Field number for the "session_id" field.</summary>
    public const int SessionIdFieldNumber = 2;
    private readonly static pb::ByteString SessionIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString sessionId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SessionId {
      get { return sessionId_ ?? SessionIdDefaultValue; }
      set {
        sessionId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "session_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSessionId {
      get { return sessionId_ != null; }
    }
    /// <summary>Clears the value of the "session_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionId() {
      sessionId_ = null;
    }

    /// <summary>Field number for the "purchase_id" field.</summary>
    public const int PurchaseIdFieldNumber = 3;
    private readonly static pb::ByteString PurchaseIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString purchaseId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PurchaseId {
      get { return purchaseId_ ?? PurchaseIdDefaultValue; }
      set {
        purchaseId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "purchase_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPurchaseId {
      get { return purchaseId_ != null; }
    }
    /// <summary>Clears the value of the "purchase_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPurchaseId() {
      purchaseId_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static global::AAXClean.Widevine.Provisioning.LicenseType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.LicenseType.Streaming;

    private global::AAXClean.Widevine.Provisioning.LicenseType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.LicenseType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "version" field.</summary>
    public const int VersionFieldNumber = 5;
    private readonly static int VersionDefaultValue = 0;

    private int version_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Version {
      get { if ((_hasBits0 & 2) != 0) { return version_; } else { return VersionDefaultValue; } }
      set {
        _hasBits0 |= 2;
        version_ = value;
      }
    }
    /// <summary>Gets whether the "version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVersion {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVersion() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "provider_session_token" field.</summary>
    public const int ProviderSessionTokenFieldNumber = 6;
    private readonly static pb::ByteString ProviderSessionTokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString providerSessionToken_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ProviderSessionToken {
      get { return providerSessionToken_ ?? ProviderSessionTokenDefaultValue; }
      set {
        providerSessionToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "provider_session_token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProviderSessionToken {
      get { return providerSessionToken_ != null; }
    }
    /// <summary>Clears the value of the "provider_session_token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProviderSessionToken() {
      providerSessionToken_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicenseIdentification);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicenseIdentification other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RequestId != other.RequestId) return false;
      if (SessionId != other.SessionId) return false;
      if (PurchaseId != other.PurchaseId) return false;
      if (Type != other.Type) return false;
      if (Version != other.Version) return false;
      if (ProviderSessionToken != other.ProviderSessionToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequestId) hash ^= RequestId.GetHashCode();
      if (HasSessionId) hash ^= SessionId.GetHashCode();
      if (HasPurchaseId) hash ^= PurchaseId.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasVersion) hash ^= Version.GetHashCode();
      if (HasProviderSessionToken) hash ^= ProviderSessionToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRequestId) {
        output.WriteRawTag(10);
        output.WriteBytes(RequestId);
      }
      if (HasSessionId) {
        output.WriteRawTag(18);
        output.WriteBytes(SessionId);
      }
      if (HasPurchaseId) {
        output.WriteRawTag(26);
        output.WriteBytes(PurchaseId);
      }
      if (HasType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Type);
      }
      if (HasVersion) {
        output.WriteRawTag(40);
        output.WriteInt32(Version);
      }
      if (HasProviderSessionToken) {
        output.WriteRawTag(50);
        output.WriteBytes(ProviderSessionToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRequestId) {
        output.WriteRawTag(10);
        output.WriteBytes(RequestId);
      }
      if (HasSessionId) {
        output.WriteRawTag(18);
        output.WriteBytes(SessionId);
      }
      if (HasPurchaseId) {
        output.WriteRawTag(26);
        output.WriteBytes(PurchaseId);
      }
      if (HasType) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Type);
      }
      if (HasVersion) {
        output.WriteRawTag(40);
        output.WriteInt32(Version);
      }
      if (HasProviderSessionToken) {
        output.WriteRawTag(50);
        output.WriteBytes(ProviderSessionToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRequestId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
      }
      if (HasSessionId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionId);
      }
      if (HasPurchaseId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PurchaseId);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasVersion) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Version);
      }
      if (HasProviderSessionToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderSessionToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicenseIdentification other) {
      if (other == null) {
        return;
      }
      if (other.HasRequestId) {
        RequestId = other.RequestId;
      }
      if (other.HasSessionId) {
        SessionId = other.SessionId;
      }
      if (other.HasPurchaseId) {
        PurchaseId = other.PurchaseId;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasVersion) {
        Version = other.Version;
      }
      if (other.HasProviderSessionToken) {
        ProviderSessionToken = other.ProviderSessionToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RequestId = input.ReadBytes();
            break;
          }
          case 18: {
            SessionId = input.ReadBytes();
            break;
          }
          case 26: {
            PurchaseId = input.ReadBytes();
            break;
          }
          case 32: {
            Type = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
            break;
          }
          case 40: {
            Version = input.ReadInt32();
            break;
          }
          case 50: {
            ProviderSessionToken = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            RequestId = input.ReadBytes();
            break;
          }
          case 18: {
            SessionId = input.ReadBytes();
            break;
          }
          case 26: {
            PurchaseId = input.ReadBytes();
            break;
          }
          case 32: {
            Type = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
            break;
          }
          case 40: {
            Version = input.ReadInt32();
            break;
          }
          case 50: {
            ProviderSessionToken = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class License : pb::IMessage<License>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<License> _parser = new pb::MessageParser<License>(() => new License());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<License> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License(License other) : this() {
      _hasBits0 = other._hasBits0;
      id_ = other.id_ != null ? other.id_.Clone() : null;
      policy_ = other.policy_ != null ? other.policy_.Clone() : null;
      key_ = other.key_.Clone();
      licenseStartTime_ = other.licenseStartTime_;
      remoteAttestationVerified_ = other.remoteAttestationVerified_;
      providerClientToken_ = other.providerClientToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public License Clone() {
      return new License(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private global::AAXClean.Widevine.Provisioning.LicenseIdentification id_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.LicenseIdentification Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "policy" field.</summary>
    public const int PolicyFieldNumber = 2;
    private global::AAXClean.Widevine.Provisioning.License.Types.Policy policy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.License.Types.Policy Policy {
      get { return policy_; }
      set {
        policy_ = value;
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 3;
    private static readonly pb::FieldCodec<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer> _repeated_key_codec
        = pb::FieldCodec.ForMessage(26, global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Parser);
    private readonly pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer> key_ = new pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer> Key {
      get { return key_; }
    }

    /// <summary>Field number for the "license_start_time" field.</summary>
    public const int LicenseStartTimeFieldNumber = 4;
    private readonly static long LicenseStartTimeDefaultValue = 0L;

    private long licenseStartTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long LicenseStartTime {
      get { if ((_hasBits0 & 1) != 0) { return licenseStartTime_; } else { return LicenseStartTimeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        licenseStartTime_ = value;
      }
    }
    /// <summary>Gets whether the "license_start_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLicenseStartTime {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "license_start_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLicenseStartTime() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "remote_attestation_verified" field.</summary>
    public const int RemoteAttestationVerifiedFieldNumber = 5;
    private readonly static bool RemoteAttestationVerifiedDefaultValue = false;

    private bool remoteAttestationVerified_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RemoteAttestationVerified {
      get { if ((_hasBits0 & 2) != 0) { return remoteAttestationVerified_; } else { return RemoteAttestationVerifiedDefaultValue; } }
      set {
        _hasBits0 |= 2;
        remoteAttestationVerified_ = value;
      }
    }
    /// <summary>Gets whether the "remote_attestation_verified" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRemoteAttestationVerified {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "remote_attestation_verified" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRemoteAttestationVerified() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "provider_client_token" field.</summary>
    public const int ProviderClientTokenFieldNumber = 6;
    private readonly static pb::ByteString ProviderClientTokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString providerClientToken_;
    /// <summary>
    /// Client token generated by the content provider. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ProviderClientToken {
      get { return providerClientToken_ ?? ProviderClientTokenDefaultValue; }
      set {
        providerClientToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "provider_client_token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProviderClientToken {
      get { return providerClientToken_ != null; }
    }
    /// <summary>Clears the value of the "provider_client_token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProviderClientToken() {
      providerClientToken_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as License);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(License other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Id, other.Id)) return false;
      if (!object.Equals(Policy, other.Policy)) return false;
      if(!key_.Equals(other.key_)) return false;
      if (LicenseStartTime != other.LicenseStartTime) return false;
      if (RemoteAttestationVerified != other.RemoteAttestationVerified) return false;
      if (ProviderClientToken != other.ProviderClientToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (id_ != null) hash ^= Id.GetHashCode();
      if (policy_ != null) hash ^= Policy.GetHashCode();
      hash ^= key_.GetHashCode();
      if (HasLicenseStartTime) hash ^= LicenseStartTime.GetHashCode();
      if (HasRemoteAttestationVerified) hash ^= RemoteAttestationVerified.GetHashCode();
      if (HasProviderClientToken) hash ^= ProviderClientToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (policy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Policy);
      }
      key_.WriteTo(output, _repeated_key_codec);
      if (HasLicenseStartTime) {
        output.WriteRawTag(32);
        output.WriteInt64(LicenseStartTime);
      }
      if (HasRemoteAttestationVerified) {
        output.WriteRawTag(40);
        output.WriteBool(RemoteAttestationVerified);
      }
      if (HasProviderClientToken) {
        output.WriteRawTag(50);
        output.WriteBytes(ProviderClientToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (id_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Id);
      }
      if (policy_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Policy);
      }
      key_.WriteTo(ref output, _repeated_key_codec);
      if (HasLicenseStartTime) {
        output.WriteRawTag(32);
        output.WriteInt64(LicenseStartTime);
      }
      if (HasRemoteAttestationVerified) {
        output.WriteRawTag(40);
        output.WriteBool(RemoteAttestationVerified);
      }
      if (HasProviderClientToken) {
        output.WriteRawTag(50);
        output.WriteBytes(ProviderClientToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (id_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Id);
      }
      if (policy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Policy);
      }
      size += key_.CalculateSize(_repeated_key_codec);
      if (HasLicenseStartTime) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LicenseStartTime);
      }
      if (HasRemoteAttestationVerified) {
        size += 1 + 1;
      }
      if (HasProviderClientToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderClientToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(License other) {
      if (other == null) {
        return;
      }
      if (other.id_ != null) {
        if (id_ == null) {
          Id = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
        }
        Id.MergeFrom(other.Id);
      }
      if (other.policy_ != null) {
        if (policy_ == null) {
          Policy = new global::AAXClean.Widevine.Provisioning.License.Types.Policy();
        }
        Policy.MergeFrom(other.Policy);
      }
      key_.Add(other.key_);
      if (other.HasLicenseStartTime) {
        LicenseStartTime = other.LicenseStartTime;
      }
      if (other.HasRemoteAttestationVerified) {
        RemoteAttestationVerified = other.RemoteAttestationVerified;
      }
      if (other.HasProviderClientToken) {
        ProviderClientToken = other.ProviderClientToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (policy_ == null) {
              Policy = new global::AAXClean.Widevine.Provisioning.License.Types.Policy();
            }
            input.ReadMessage(Policy);
            break;
          }
          case 26: {
            key_.AddEntriesFrom(input, _repeated_key_codec);
            break;
          }
          case 32: {
            LicenseStartTime = input.ReadInt64();
            break;
          }
          case 40: {
            RemoteAttestationVerified = input.ReadBool();
            break;
          }
          case 50: {
            ProviderClientToken = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (id_ == null) {
              Id = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
            }
            input.ReadMessage(Id);
            break;
          }
          case 18: {
            if (policy_ == null) {
              Policy = new global::AAXClean.Widevine.Provisioning.License.Types.Policy();
            }
            input.ReadMessage(Policy);
            break;
          }
          case 26: {
            key_.AddEntriesFrom(ref input, _repeated_key_codec);
            break;
          }
          case 32: {
            LicenseStartTime = input.ReadInt64();
            break;
          }
          case 40: {
            RemoteAttestationVerified = input.ReadBool();
            break;
          }
          case 50: {
            ProviderClientToken = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the License message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Policy : pb::IMessage<Policy>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Policy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AAXClean.Widevine.Provisioning.License.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy(Policy other) : this() {
          _hasBits0 = other._hasBits0;
          canPlay_ = other.canPlay_;
          canPersist_ = other.canPersist_;
          canRenew_ = other.canRenew_;
          rentalDurationSeconds_ = other.rentalDurationSeconds_;
          playbackDurationSeconds_ = other.playbackDurationSeconds_;
          licenseDurationSeconds_ = other.licenseDurationSeconds_;
          renewalRecoveryDurationSeconds_ = other.renewalRecoveryDurationSeconds_;
          renewalServerUrl_ = other.renewalServerUrl_;
          renewalDelaySeconds_ = other.renewalDelaySeconds_;
          renewalRetryIntervalSeconds_ = other.renewalRetryIntervalSeconds_;
          renewWithUsage_ = other.renewWithUsage_;
          renewWithClientId_ = other.renewWithClientId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Policy Clone() {
          return new Policy(this);
        }

        /// <summary>Field number for the "can_play" field.</summary>
        public const int CanPlayFieldNumber = 1;
        private readonly static bool CanPlayDefaultValue = false;

        private bool canPlay_;
        /// <summary>
        /// Indicates that playback of the content is allowed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CanPlay {
          get { if ((_hasBits0 & 1) != 0) { return canPlay_; } else { return CanPlayDefaultValue; } }
          set {
            _hasBits0 |= 1;
            canPlay_ = value;
          }
        }
        /// <summary>Gets whether the "can_play" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCanPlay {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "can_play" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCanPlay() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "can_persist" field.</summary>
        public const int CanPersistFieldNumber = 2;
        private readonly static bool CanPersistDefaultValue = false;

        private bool canPersist_;
        /// <summary>
        /// Indicates that the license may be persisted to non-volatile
        /// storage for offline use.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CanPersist {
          get { if ((_hasBits0 & 2) != 0) { return canPersist_; } else { return CanPersistDefaultValue; } }
          set {
            _hasBits0 |= 2;
            canPersist_ = value;
          }
        }
        /// <summary>Gets whether the "can_persist" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCanPersist {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "can_persist" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCanPersist() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "can_renew" field.</summary>
        public const int CanRenewFieldNumber = 3;
        private readonly static bool CanRenewDefaultValue = false;

        private bool canRenew_;
        /// <summary>
        /// Indicates that renewal of this license is allowed.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool CanRenew {
          get { if ((_hasBits0 & 4) != 0) { return canRenew_; } else { return CanRenewDefaultValue; } }
          set {
            _hasBits0 |= 4;
            canRenew_ = value;
          }
        }
        /// <summary>Gets whether the "can_renew" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasCanRenew {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "can_renew" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearCanRenew() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "rental_duration_seconds" field.</summary>
        public const int RentalDurationSecondsFieldNumber = 4;
        private readonly static long RentalDurationSecondsDefaultValue = 0L;

        private long rentalDurationSeconds_;
        /// <summary>
        /// Indicates the rental window.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long RentalDurationSeconds {
          get { if ((_hasBits0 & 8) != 0) { return rentalDurationSeconds_; } else { return RentalDurationSecondsDefaultValue; } }
          set {
            _hasBits0 |= 8;
            rentalDurationSeconds_ = value;
          }
        }
        /// <summary>Gets whether the "rental_duration_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRentalDurationSeconds {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "rental_duration_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRentalDurationSeconds() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "playback_duration_seconds" field.</summary>
        public const int PlaybackDurationSecondsFieldNumber = 5;
        private readonly static long PlaybackDurationSecondsDefaultValue = 0L;

        private long playbackDurationSeconds_;
        /// <summary>
        /// Indicates the viewing window, once playback has begun.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long PlaybackDurationSeconds {
          get { if ((_hasBits0 & 16) != 0) { return playbackDurationSeconds_; } else { return PlaybackDurationSecondsDefaultValue; } }
          set {
            _hasBits0 |= 16;
            playbackDurationSeconds_ = value;
          }
        }
        /// <summary>Gets whether the "playback_duration_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasPlaybackDurationSeconds {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "playback_duration_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearPlaybackDurationSeconds() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "license_duration_seconds" field.</summary>
        public const int LicenseDurationSecondsFieldNumber = 6;
        private readonly static long LicenseDurationSecondsDefaultValue = 0L;

        private long licenseDurationSeconds_;
        /// <summary>
        /// Indicates the time window for this specific license.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long LicenseDurationSeconds {
          get { if ((_hasBits0 & 32) != 0) { return licenseDurationSeconds_; } else { return LicenseDurationSecondsDefaultValue; } }
          set {
            _hasBits0 |= 32;
            licenseDurationSeconds_ = value;
          }
        }
        /// <summary>Gets whether the "license_duration_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLicenseDurationSeconds {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "license_duration_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLicenseDurationSeconds() {
          _hasBits0 &= ~32;
        }

        /// <summary>Field number for the "renewal_recovery_duration_seconds" field.</summary>
        public const int RenewalRecoveryDurationSecondsFieldNumber = 7;
        private readonly static long RenewalRecoveryDurationSecondsDefaultValue = 0L;

        private long renewalRecoveryDurationSeconds_;
        /// <summary>
        /// The window of time, in which playback is allowed to continue while
        /// renewal is attempted, yet unsuccessful due to backend problems with
        /// the license server.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long RenewalRecoveryDurationSeconds {
          get { if ((_hasBits0 & 64) != 0) { return renewalRecoveryDurationSeconds_; } else { return RenewalRecoveryDurationSecondsDefaultValue; } }
          set {
            _hasBits0 |= 64;
            renewalRecoveryDurationSeconds_ = value;
          }
        }
        /// <summary>Gets whether the "renewal_recovery_duration_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewalRecoveryDurationSeconds {
          get { return (_hasBits0 & 64) != 0; }
        }
        /// <summary>Clears the value of the "renewal_recovery_duration_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewalRecoveryDurationSeconds() {
          _hasBits0 &= ~64;
        }

        /// <summary>Field number for the "renewal_server_url" field.</summary>
        public const int RenewalServerUrlFieldNumber = 8;
        private readonly static string RenewalServerUrlDefaultValue = "";

        private string renewalServerUrl_;
        /// <summary>
        /// All renewal requests for this license shall be directed to the
        /// specified URL.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string RenewalServerUrl {
          get { return renewalServerUrl_ ?? RenewalServerUrlDefaultValue; }
          set {
            renewalServerUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "renewal_server_url" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewalServerUrl {
          get { return renewalServerUrl_ != null; }
        }
        /// <summary>Clears the value of the "renewal_server_url" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewalServerUrl() {
          renewalServerUrl_ = null;
        }

        /// <summary>Field number for the "renewal_delay_seconds" field.</summary>
        public const int RenewalDelaySecondsFieldNumber = 9;
        private readonly static long RenewalDelaySecondsDefaultValue = 0L;

        private long renewalDelaySeconds_;
        /// <summary>
        /// How many seconds after license_start_time, before renewal is first
        /// attempted.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long RenewalDelaySeconds {
          get { if ((_hasBits0 & 128) != 0) { return renewalDelaySeconds_; } else { return RenewalDelaySecondsDefaultValue; } }
          set {
            _hasBits0 |= 128;
            renewalDelaySeconds_ = value;
          }
        }
        /// <summary>Gets whether the "renewal_delay_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewalDelaySeconds {
          get { return (_hasBits0 & 128) != 0; }
        }
        /// <summary>Clears the value of the "renewal_delay_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewalDelaySeconds() {
          _hasBits0 &= ~128;
        }

        /// <summary>Field number for the "renewal_retry_interval_seconds" field.</summary>
        public const int RenewalRetryIntervalSecondsFieldNumber = 10;
        private readonly static long RenewalRetryIntervalSecondsDefaultValue = 0L;

        private long renewalRetryIntervalSeconds_;
        /// <summary>
        /// Specifies the delay in seconds between subsequent license
        /// renewal requests, in case of failure.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long RenewalRetryIntervalSeconds {
          get { if ((_hasBits0 & 256) != 0) { return renewalRetryIntervalSeconds_; } else { return RenewalRetryIntervalSecondsDefaultValue; } }
          set {
            _hasBits0 |= 256;
            renewalRetryIntervalSeconds_ = value;
          }
        }
        /// <summary>Gets whether the "renewal_retry_interval_seconds" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewalRetryIntervalSeconds {
          get { return (_hasBits0 & 256) != 0; }
        }
        /// <summary>Clears the value of the "renewal_retry_interval_seconds" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewalRetryIntervalSeconds() {
          _hasBits0 &= ~256;
        }

        /// <summary>Field number for the "renew_with_usage" field.</summary>
        public const int RenewWithUsageFieldNumber = 11;
        private readonly static bool RenewWithUsageDefaultValue = false;

        private bool renewWithUsage_;
        /// <summary>
        /// Indicates that the license shall be sent for renewal when usage is
        /// started.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RenewWithUsage {
          get { if ((_hasBits0 & 512) != 0) { return renewWithUsage_; } else { return RenewWithUsageDefaultValue; } }
          set {
            _hasBits0 |= 512;
            renewWithUsage_ = value;
          }
        }
        /// <summary>Gets whether the "renew_with_usage" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewWithUsage {
          get { return (_hasBits0 & 512) != 0; }
        }
        /// <summary>Clears the value of the "renew_with_usage" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewWithUsage() {
          _hasBits0 &= ~512;
        }

        /// <summary>Field number for the "renew_with_client_id" field.</summary>
        public const int RenewWithClientIdFieldNumber = 12;
        private readonly static bool RenewWithClientIdDefaultValue = false;

        private bool renewWithClientId_;
        /// <summary>
        /// Indicates to client that license renewal and release requests ought to
        /// include ClientIdentification (client_id).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RenewWithClientId {
          get { if ((_hasBits0 & 1024) != 0) { return renewWithClientId_; } else { return RenewWithClientIdDefaultValue; } }
          set {
            _hasBits0 |= 1024;
            renewWithClientId_ = value;
          }
        }
        /// <summary>Gets whether the "renew_with_client_id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasRenewWithClientId {
          get { return (_hasBits0 & 1024) != 0; }
        }
        /// <summary>Clears the value of the "renew_with_client_id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearRenewWithClientId() {
          _hasBits0 &= ~1024;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Policy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Policy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (CanPlay != other.CanPlay) return false;
          if (CanPersist != other.CanPersist) return false;
          if (CanRenew != other.CanRenew) return false;
          if (RentalDurationSeconds != other.RentalDurationSeconds) return false;
          if (PlaybackDurationSeconds != other.PlaybackDurationSeconds) return false;
          if (LicenseDurationSeconds != other.LicenseDurationSeconds) return false;
          if (RenewalRecoveryDurationSeconds != other.RenewalRecoveryDurationSeconds) return false;
          if (RenewalServerUrl != other.RenewalServerUrl) return false;
          if (RenewalDelaySeconds != other.RenewalDelaySeconds) return false;
          if (RenewalRetryIntervalSeconds != other.RenewalRetryIntervalSeconds) return false;
          if (RenewWithUsage != other.RenewWithUsage) return false;
          if (RenewWithClientId != other.RenewWithClientId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasCanPlay) hash ^= CanPlay.GetHashCode();
          if (HasCanPersist) hash ^= CanPersist.GetHashCode();
          if (HasCanRenew) hash ^= CanRenew.GetHashCode();
          if (HasRentalDurationSeconds) hash ^= RentalDurationSeconds.GetHashCode();
          if (HasPlaybackDurationSeconds) hash ^= PlaybackDurationSeconds.GetHashCode();
          if (HasLicenseDurationSeconds) hash ^= LicenseDurationSeconds.GetHashCode();
          if (HasRenewalRecoveryDurationSeconds) hash ^= RenewalRecoveryDurationSeconds.GetHashCode();
          if (HasRenewalServerUrl) hash ^= RenewalServerUrl.GetHashCode();
          if (HasRenewalDelaySeconds) hash ^= RenewalDelaySeconds.GetHashCode();
          if (HasRenewalRetryIntervalSeconds) hash ^= RenewalRetryIntervalSeconds.GetHashCode();
          if (HasRenewWithUsage) hash ^= RenewWithUsage.GetHashCode();
          if (HasRenewWithClientId) hash ^= RenewWithClientId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasCanPlay) {
            output.WriteRawTag(8);
            output.WriteBool(CanPlay);
          }
          if (HasCanPersist) {
            output.WriteRawTag(16);
            output.WriteBool(CanPersist);
          }
          if (HasCanRenew) {
            output.WriteRawTag(24);
            output.WriteBool(CanRenew);
          }
          if (HasRentalDurationSeconds) {
            output.WriteRawTag(32);
            output.WriteInt64(RentalDurationSeconds);
          }
          if (HasPlaybackDurationSeconds) {
            output.WriteRawTag(40);
            output.WriteInt64(PlaybackDurationSeconds);
          }
          if (HasLicenseDurationSeconds) {
            output.WriteRawTag(48);
            output.WriteInt64(LicenseDurationSeconds);
          }
          if (HasRenewalRecoveryDurationSeconds) {
            output.WriteRawTag(56);
            output.WriteInt64(RenewalRecoveryDurationSeconds);
          }
          if (HasRenewalServerUrl) {
            output.WriteRawTag(66);
            output.WriteString(RenewalServerUrl);
          }
          if (HasRenewalDelaySeconds) {
            output.WriteRawTag(72);
            output.WriteInt64(RenewalDelaySeconds);
          }
          if (HasRenewalRetryIntervalSeconds) {
            output.WriteRawTag(80);
            output.WriteInt64(RenewalRetryIntervalSeconds);
          }
          if (HasRenewWithUsage) {
            output.WriteRawTag(88);
            output.WriteBool(RenewWithUsage);
          }
          if (HasRenewWithClientId) {
            output.WriteRawTag(96);
            output.WriteBool(RenewWithClientId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasCanPlay) {
            output.WriteRawTag(8);
            output.WriteBool(CanPlay);
          }
          if (HasCanPersist) {
            output.WriteRawTag(16);
            output.WriteBool(CanPersist);
          }
          if (HasCanRenew) {
            output.WriteRawTag(24);
            output.WriteBool(CanRenew);
          }
          if (HasRentalDurationSeconds) {
            output.WriteRawTag(32);
            output.WriteInt64(RentalDurationSeconds);
          }
          if (HasPlaybackDurationSeconds) {
            output.WriteRawTag(40);
            output.WriteInt64(PlaybackDurationSeconds);
          }
          if (HasLicenseDurationSeconds) {
            output.WriteRawTag(48);
            output.WriteInt64(LicenseDurationSeconds);
          }
          if (HasRenewalRecoveryDurationSeconds) {
            output.WriteRawTag(56);
            output.WriteInt64(RenewalRecoveryDurationSeconds);
          }
          if (HasRenewalServerUrl) {
            output.WriteRawTag(66);
            output.WriteString(RenewalServerUrl);
          }
          if (HasRenewalDelaySeconds) {
            output.WriteRawTag(72);
            output.WriteInt64(RenewalDelaySeconds);
          }
          if (HasRenewalRetryIntervalSeconds) {
            output.WriteRawTag(80);
            output.WriteInt64(RenewalRetryIntervalSeconds);
          }
          if (HasRenewWithUsage) {
            output.WriteRawTag(88);
            output.WriteBool(RenewWithUsage);
          }
          if (HasRenewWithClientId) {
            output.WriteRawTag(96);
            output.WriteBool(RenewWithClientId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasCanPlay) {
            size += 1 + 1;
          }
          if (HasCanPersist) {
            size += 1 + 1;
          }
          if (HasCanRenew) {
            size += 1 + 1;
          }
          if (HasRentalDurationSeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(RentalDurationSeconds);
          }
          if (HasPlaybackDurationSeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(PlaybackDurationSeconds);
          }
          if (HasLicenseDurationSeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(LicenseDurationSeconds);
          }
          if (HasRenewalRecoveryDurationSeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalRecoveryDurationSeconds);
          }
          if (HasRenewalServerUrl) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RenewalServerUrl);
          }
          if (HasRenewalDelaySeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalDelaySeconds);
          }
          if (HasRenewalRetryIntervalSeconds) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(RenewalRetryIntervalSeconds);
          }
          if (HasRenewWithUsage) {
            size += 1 + 1;
          }
          if (HasRenewWithClientId) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Policy other) {
          if (other == null) {
            return;
          }
          if (other.HasCanPlay) {
            CanPlay = other.CanPlay;
          }
          if (other.HasCanPersist) {
            CanPersist = other.CanPersist;
          }
          if (other.HasCanRenew) {
            CanRenew = other.CanRenew;
          }
          if (other.HasRentalDurationSeconds) {
            RentalDurationSeconds = other.RentalDurationSeconds;
          }
          if (other.HasPlaybackDurationSeconds) {
            PlaybackDurationSeconds = other.PlaybackDurationSeconds;
          }
          if (other.HasLicenseDurationSeconds) {
            LicenseDurationSeconds = other.LicenseDurationSeconds;
          }
          if (other.HasRenewalRecoveryDurationSeconds) {
            RenewalRecoveryDurationSeconds = other.RenewalRecoveryDurationSeconds;
          }
          if (other.HasRenewalServerUrl) {
            RenewalServerUrl = other.RenewalServerUrl;
          }
          if (other.HasRenewalDelaySeconds) {
            RenewalDelaySeconds = other.RenewalDelaySeconds;
          }
          if (other.HasRenewalRetryIntervalSeconds) {
            RenewalRetryIntervalSeconds = other.RenewalRetryIntervalSeconds;
          }
          if (other.HasRenewWithUsage) {
            RenewWithUsage = other.RenewWithUsage;
          }
          if (other.HasRenewWithClientId) {
            RenewWithClientId = other.RenewWithClientId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                CanPlay = input.ReadBool();
                break;
              }
              case 16: {
                CanPersist = input.ReadBool();
                break;
              }
              case 24: {
                CanRenew = input.ReadBool();
                break;
              }
              case 32: {
                RentalDurationSeconds = input.ReadInt64();
                break;
              }
              case 40: {
                PlaybackDurationSeconds = input.ReadInt64();
                break;
              }
              case 48: {
                LicenseDurationSeconds = input.ReadInt64();
                break;
              }
              case 56: {
                RenewalRecoveryDurationSeconds = input.ReadInt64();
                break;
              }
              case 66: {
                RenewalServerUrl = input.ReadString();
                break;
              }
              case 72: {
                RenewalDelaySeconds = input.ReadInt64();
                break;
              }
              case 80: {
                RenewalRetryIntervalSeconds = input.ReadInt64();
                break;
              }
              case 88: {
                RenewWithUsage = input.ReadBool();
                break;
              }
              case 96: {
                RenewWithClientId = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                CanPlay = input.ReadBool();
                break;
              }
              case 16: {
                CanPersist = input.ReadBool();
                break;
              }
              case 24: {
                CanRenew = input.ReadBool();
                break;
              }
              case 32: {
                RentalDurationSeconds = input.ReadInt64();
                break;
              }
              case 40: {
                PlaybackDurationSeconds = input.ReadInt64();
                break;
              }
              case 48: {
                LicenseDurationSeconds = input.ReadInt64();
                break;
              }
              case 56: {
                RenewalRecoveryDurationSeconds = input.ReadInt64();
                break;
              }
              case 66: {
                RenewalServerUrl = input.ReadString();
                break;
              }
              case 72: {
                RenewalDelaySeconds = input.ReadInt64();
                break;
              }
              case 80: {
                RenewalRetryIntervalSeconds = input.ReadInt64();
                break;
              }
              case 88: {
                RenewWithUsage = input.ReadBool();
                break;
              }
              case 96: {
                RenewWithClientId = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class KeyContainer : pb::IMessage<KeyContainer>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<KeyContainer> _parser = new pb::MessageParser<KeyContainer>(() => new KeyContainer());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<KeyContainer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AAXClean.Widevine.Provisioning.License.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyContainer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyContainer(KeyContainer other) : this() {
          _hasBits0 = other._hasBits0;
          id_ = other.id_;
          iv_ = other.iv_;
          key_ = other.key_;
          type_ = other.type_;
          level_ = other.level_;
          requiredProtection_ = other.requiredProtection_ != null ? other.requiredProtection_.Clone() : null;
          requestedProtection_ = other.requestedProtection_ != null ? other.requestedProtection_.Clone() : null;
          keyControl_ = other.keyControl_ != null ? other.keyControl_.Clone() : null;
          operatorSessionKeyPermissions_ = other.operatorSessionKeyPermissions_ != null ? other.operatorSessionKeyPermissions_.Clone() : null;
          videoResolutionConstraints_ = other.videoResolutionConstraints_.Clone();
          antiRollbackUsageTable_ = other.antiRollbackUsageTable_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public KeyContainer Clone() {
          return new KeyContainer(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private readonly static pb::ByteString IdDefaultValue = pb::ByteString.Empty;

        private pb::ByteString id_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Id {
          get { return id_ ?? IdDefaultValue; }
          set {
            id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "id" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasId {
          get { return id_ != null; }
        }
        /// <summary>Clears the value of the "id" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearId() {
          id_ = null;
        }

        /// <summary>Field number for the "iv" field.</summary>
        public const int IvFieldNumber = 2;
        private readonly static pb::ByteString IvDefaultValue = pb::ByteString.Empty;

        private pb::ByteString iv_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Iv {
          get { return iv_ ?? IvDefaultValue; }
          set {
            iv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "iv" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasIv {
          get { return iv_ != null; }
        }
        /// <summary>Clears the value of the "iv" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearIv() {
          iv_ = null;
        }

        /// <summary>Field number for the "key" field.</summary>
        public const int KeyFieldNumber = 3;
        private readonly static pb::ByteString KeyDefaultValue = pb::ByteString.Empty;

        private pb::ByteString key_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pb::ByteString Key {
          get { return key_ ?? KeyDefaultValue; }
          set {
            key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "key" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasKey {
          get { return key_ != null; }
        }
        /// <summary>Clears the value of the "key" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearKey() {
          key_ = null;
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 4;
        private readonly static global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType.Signing;

        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType type_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType Type {
          get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
          set {
            _hasBits0 |= 1;
            type_ = value;
          }
        }
        /// <summary>Gets whether the "type" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasType {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "type" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearType() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "level" field.</summary>
        public const int LevelFieldNumber = 5;
        private readonly static global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel LevelDefaultValue = global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel.SwSecureCrypto;

        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel level_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel Level {
          get { if ((_hasBits0 & 2) != 0) { return level_; } else { return LevelDefaultValue; } }
          set {
            _hasBits0 |= 2;
            level_ = value;
          }
        }
        /// <summary>Gets whether the "level" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasLevel {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "level" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearLevel() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "required_protection" field.</summary>
        public const int RequiredProtectionFieldNumber = 6;
        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection requiredProtection_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection RequiredProtection {
          get { return requiredProtection_; }
          set {
            requiredProtection_ = value;
          }
        }

        /// <summary>Field number for the "requested_protection" field.</summary>
        public const int RequestedProtectionFieldNumber = 7;
        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection requestedProtection_;
        /// <summary>
        /// NOTE: Use of requested_protection is not recommended as it is only
        /// supported on a small number of platforms.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection RequestedProtection {
          get { return requestedProtection_; }
          set {
            requestedProtection_ = value;
          }
        }

        /// <summary>Field number for the "key_control" field.</summary>
        public const int KeyControlFieldNumber = 8;
        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl keyControl_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl KeyControl {
          get { return keyControl_; }
          set {
            keyControl_ = value;
          }
        }

        /// <summary>Field number for the "operator_session_key_permissions" field.</summary>
        public const int OperatorSessionKeyPermissionsFieldNumber = 9;
        private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions operatorSessionKeyPermissions_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions OperatorSessionKeyPermissions {
          get { return operatorSessionKeyPermissions_; }
          set {
            operatorSessionKeyPermissions_ = value;
          }
        }

        /// <summary>Field number for the "video_resolution_constraints" field.</summary>
        public const int VideoResolutionConstraintsFieldNumber = 10;
        private static readonly pb::FieldCodec<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint> _repeated_videoResolutionConstraints_codec
            = pb::FieldCodec.ForMessage(82, global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint.Parser);
        private readonly pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint> videoResolutionConstraints_ = new pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint>();
        /// <summary>
        /// Optional video resolution constraints. If the video resolution of the
        /// content being decrypted/decoded falls within one of the specified ranges,
        /// the optional required_protections may be applied. Otherwise an error will
        /// be reported.
        /// NOTE: Use of this feature is not recommended, as it is only supported on
        /// a small number of platforms.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.VideoResolutionConstraint> VideoResolutionConstraints {
          get { return videoResolutionConstraints_; }
        }

        /// <summary>Field number for the "anti_rollback_usage_table" field.</summary>
        public const int AntiRollbackUsageTableFieldNumber = 11;
        private readonly static bool AntiRollbackUsageTableDefaultValue = false;

        private bool antiRollbackUsageTable_;
        /// <summary>
        /// Optional flag to indicate the key must only be used if the client
        /// supports anti rollback of the user table.  Content provider can query the
        /// client capabilities to determine if the client support this feature.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AntiRollbackUsageTable {
          get { if ((_hasBits0 & 4) != 0) { return antiRollbackUsageTable_; } else { return AntiRollbackUsageTableDefaultValue; } }
          set {
            _hasBits0 |= 4;
            antiRollbackUsageTable_ = value;
          }
        }
        /// <summary>Gets whether the "anti_rollback_usage_table" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAntiRollbackUsageTable {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "anti_rollback_usage_table" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAntiRollbackUsageTable() {
          _hasBits0 &= ~4;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as KeyContainer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(KeyContainer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Iv != other.Iv) return false;
          if (Key != other.Key) return false;
          if (Type != other.Type) return false;
          if (Level != other.Level) return false;
          if (!object.Equals(RequiredProtection, other.RequiredProtection)) return false;
          if (!object.Equals(RequestedProtection, other.RequestedProtection)) return false;
          if (!object.Equals(KeyControl, other.KeyControl)) return false;
          if (!object.Equals(OperatorSessionKeyPermissions, other.OperatorSessionKeyPermissions)) return false;
          if(!videoResolutionConstraints_.Equals(other.videoResolutionConstraints_)) return false;
          if (AntiRollbackUsageTable != other.AntiRollbackUsageTable) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasId) hash ^= Id.GetHashCode();
          if (HasIv) hash ^= Iv.GetHashCode();
          if (HasKey) hash ^= Key.GetHashCode();
          if (HasType) hash ^= Type.GetHashCode();
          if (HasLevel) hash ^= Level.GetHashCode();
          if (requiredProtection_ != null) hash ^= RequiredProtection.GetHashCode();
          if (requestedProtection_ != null) hash ^= RequestedProtection.GetHashCode();
          if (keyControl_ != null) hash ^= KeyControl.GetHashCode();
          if (operatorSessionKeyPermissions_ != null) hash ^= OperatorSessionKeyPermissions.GetHashCode();
          hash ^= videoResolutionConstraints_.GetHashCode();
          if (HasAntiRollbackUsageTable) hash ^= AntiRollbackUsageTable.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasId) {
            output.WriteRawTag(10);
            output.WriteBytes(Id);
          }
          if (HasIv) {
            output.WriteRawTag(18);
            output.WriteBytes(Iv);
          }
          if (HasKey) {
            output.WriteRawTag(26);
            output.WriteBytes(Key);
          }
          if (HasType) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Type);
          }
          if (HasLevel) {
            output.WriteRawTag(40);
            output.WriteEnum((int) Level);
          }
          if (requiredProtection_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(RequiredProtection);
          }
          if (requestedProtection_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(RequestedProtection);
          }
          if (keyControl_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(KeyControl);
          }
          if (operatorSessionKeyPermissions_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(OperatorSessionKeyPermissions);
          }
          videoResolutionConstraints_.WriteTo(output, _repeated_videoResolutionConstraints_codec);
          if (HasAntiRollbackUsageTable) {
            output.WriteRawTag(88);
            output.WriteBool(AntiRollbackUsageTable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasId) {
            output.WriteRawTag(10);
            output.WriteBytes(Id);
          }
          if (HasIv) {
            output.WriteRawTag(18);
            output.WriteBytes(Iv);
          }
          if (HasKey) {
            output.WriteRawTag(26);
            output.WriteBytes(Key);
          }
          if (HasType) {
            output.WriteRawTag(32);
            output.WriteEnum((int) Type);
          }
          if (HasLevel) {
            output.WriteRawTag(40);
            output.WriteEnum((int) Level);
          }
          if (requiredProtection_ != null) {
            output.WriteRawTag(50);
            output.WriteMessage(RequiredProtection);
          }
          if (requestedProtection_ != null) {
            output.WriteRawTag(58);
            output.WriteMessage(RequestedProtection);
          }
          if (keyControl_ != null) {
            output.WriteRawTag(66);
            output.WriteMessage(KeyControl);
          }
          if (operatorSessionKeyPermissions_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(OperatorSessionKeyPermissions);
          }
          videoResolutionConstraints_.WriteTo(ref output, _repeated_videoResolutionConstraints_codec);
          if (HasAntiRollbackUsageTable) {
            output.WriteRawTag(88);
            output.WriteBool(AntiRollbackUsageTable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasId) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Id);
          }
          if (HasIv) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Iv);
          }
          if (HasKey) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(Key);
          }
          if (HasType) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (HasLevel) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Level);
          }
          if (requiredProtection_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequiredProtection);
          }
          if (requestedProtection_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestedProtection);
          }
          if (keyControl_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(KeyControl);
          }
          if (operatorSessionKeyPermissions_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OperatorSessionKeyPermissions);
          }
          size += videoResolutionConstraints_.CalculateSize(_repeated_videoResolutionConstraints_codec);
          if (HasAntiRollbackUsageTable) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(KeyContainer other) {
          if (other == null) {
            return;
          }
          if (other.HasId) {
            Id = other.Id;
          }
          if (other.HasIv) {
            Iv = other.Iv;
          }
          if (other.HasKey) {
            Key = other.Key;
          }
          if (other.HasType) {
            Type = other.Type;
          }
          if (other.HasLevel) {
            Level = other.Level;
          }
          if (other.requiredProtection_ != null) {
            if (requiredProtection_ == null) {
              RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
            }
            RequiredProtection.MergeFrom(other.RequiredProtection);
          }
          if (other.requestedProtection_ != null) {
            if (requestedProtection_ == null) {
              RequestedProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
            }
            RequestedProtection.MergeFrom(other.RequestedProtection);
          }
          if (other.keyControl_ != null) {
            if (keyControl_ == null) {
              KeyControl = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl();
            }
            KeyControl.MergeFrom(other.KeyControl);
          }
          if (other.operatorSessionKeyPermissions_ != null) {
            if (operatorSessionKeyPermissions_ == null) {
              OperatorSessionKeyPermissions = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
            }
            OperatorSessionKeyPermissions.MergeFrom(other.OperatorSessionKeyPermissions);
          }
          videoResolutionConstraints_.Add(other.videoResolutionConstraints_);
          if (other.HasAntiRollbackUsageTable) {
            AntiRollbackUsageTable = other.AntiRollbackUsageTable;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Id = input.ReadBytes();
                break;
              }
              case 18: {
                Iv = input.ReadBytes();
                break;
              }
              case 26: {
                Key = input.ReadBytes();
                break;
              }
              case 32: {
                Type = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType) input.ReadEnum();
                break;
              }
              case 40: {
                Level = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel) input.ReadEnum();
                break;
              }
              case 50: {
                if (requiredProtection_ == null) {
                  RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequiredProtection);
                break;
              }
              case 58: {
                if (requestedProtection_ == null) {
                  RequestedProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequestedProtection);
                break;
              }
              case 66: {
                if (keyControl_ == null) {
                  KeyControl = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl();
                }
                input.ReadMessage(KeyControl);
                break;
              }
              case 74: {
                if (operatorSessionKeyPermissions_ == null) {
                  OperatorSessionKeyPermissions = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
                }
                input.ReadMessage(OperatorSessionKeyPermissions);
                break;
              }
              case 82: {
                videoResolutionConstraints_.AddEntriesFrom(input, _repeated_videoResolutionConstraints_codec);
                break;
              }
              case 88: {
                AntiRollbackUsageTable = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Id = input.ReadBytes();
                break;
              }
              case 18: {
                Iv = input.ReadBytes();
                break;
              }
              case 26: {
                Key = input.ReadBytes();
                break;
              }
              case 32: {
                Type = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyType) input.ReadEnum();
                break;
              }
              case 40: {
                Level = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.SecurityLevel) input.ReadEnum();
                break;
              }
              case 50: {
                if (requiredProtection_ == null) {
                  RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequiredProtection);
                break;
              }
              case 58: {
                if (requestedProtection_ == null) {
                  RequestedProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                }
                input.ReadMessage(RequestedProtection);
                break;
              }
              case 66: {
                if (keyControl_ == null) {
                  KeyControl = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.KeyControl();
                }
                input.ReadMessage(KeyControl);
                break;
              }
              case 74: {
                if (operatorSessionKeyPermissions_ == null) {
                  OperatorSessionKeyPermissions = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OperatorSessionKeyPermissions();
                }
                input.ReadMessage(OperatorSessionKeyPermissions);
                break;
              }
              case 82: {
                videoResolutionConstraints_.AddEntriesFrom(ref input, _repeated_videoResolutionConstraints_codec);
                break;
              }
              case 88: {
                AntiRollbackUsageTable = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the KeyContainer message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum KeyType {
            /// <summary>
            /// Exactly one key of this type must appear.
            /// </summary>
            [pbr::OriginalName("SIGNING")] Signing = 1,
            [pbr::OriginalName("CONTENT")] Content = 2,
            [pbr::OriginalName("KEY_CONTROL")] KeyControl = 3,
            [pbr::OriginalName("OPERATOR_SESSION")] OperatorSession = 4,
          }

          /// <summary>
          /// The SecurityLevel enumeration allows the server to communicate the level
          /// of robustness required by the client, in order to use the key.
          /// </summary>
          public enum SecurityLevel {
            /// <summary>
            /// Software-based whitebox crypto is required.
            /// </summary>
            [pbr::OriginalName("SW_SECURE_CRYPTO")] SwSecureCrypto = 1,
            /// <summary>
            /// Software crypto and an obfuscated decoder is required.
            /// </summary>
            [pbr::OriginalName("SW_SECURE_DECODE")] SwSecureDecode = 2,
            /// <summary>
            /// The key material and crypto operations must be performed within a
            /// hardware backed trusted execution environment.
            /// </summary>
            [pbr::OriginalName("HW_SECURE_CRYPTO")] HwSecureCrypto = 3,
            /// <summary>
            /// The crypto and decoding of content must be performed within a hardware
            /// backed trusted execution environment.
            /// </summary>
            [pbr::OriginalName("HW_SECURE_DECODE")] HwSecureDecode = 4,
            /// <summary>
            /// The crypto, decoding and all handling of the media (compressed and
            /// uncompressed) must be handled within a hardware backed trusted
            /// execution environment.
            /// </summary>
            [pbr::OriginalName("HW_SECURE_ALL")] HwSecureAll = 5,
          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class KeyControl : pb::IMessage<KeyControl>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<KeyControl> _parser = new pb::MessageParser<KeyControl>(() => new KeyControl());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<KeyControl> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public KeyControl() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public KeyControl(KeyControl other) : this() {
              keyControlBlock_ = other.keyControlBlock_;
              iv_ = other.iv_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public KeyControl Clone() {
              return new KeyControl(this);
            }

            /// <summary>Field number for the "key_control_block" field.</summary>
            public const int KeyControlBlockFieldNumber = 1;
            private readonly static pb::ByteString KeyControlBlockDefaultValue = pb::ByteString.Empty;

            private pb::ByteString keyControlBlock_;
            /// <summary>
            /// If present, the key control must be communicated to the secure
            /// environment prior to any usage. This message is automatically generated
            /// by the Widevine License Server SDK.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString KeyControlBlock {
              get { return keyControlBlock_ ?? KeyControlBlockDefaultValue; }
              set {
                keyControlBlock_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "key_control_block" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasKeyControlBlock {
              get { return keyControlBlock_ != null; }
            }
            /// <summary>Clears the value of the "key_control_block" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearKeyControlBlock() {
              keyControlBlock_ = null;
            }

            /// <summary>Field number for the "iv" field.</summary>
            public const int IvFieldNumber = 2;
            private readonly static pb::ByteString IvDefaultValue = pb::ByteString.Empty;

            private pb::ByteString iv_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString Iv {
              get { return iv_ ?? IvDefaultValue; }
              set {
                iv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "iv" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasIv {
              get { return iv_ != null; }
            }
            /// <summary>Clears the value of the "iv" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearIv() {
              iv_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as KeyControl);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(KeyControl other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (KeyControlBlock != other.KeyControlBlock) return false;
              if (Iv != other.Iv) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasKeyControlBlock) hash ^= KeyControlBlock.GetHashCode();
              if (HasIv) hash ^= Iv.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasKeyControlBlock) {
                output.WriteRawTag(10);
                output.WriteBytes(KeyControlBlock);
              }
              if (HasIv) {
                output.WriteRawTag(18);
                output.WriteBytes(Iv);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasKeyControlBlock) {
                output.WriteRawTag(10);
                output.WriteBytes(KeyControlBlock);
              }
              if (HasIv) {
                output.WriteRawTag(18);
                output.WriteBytes(Iv);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasKeyControlBlock) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyControlBlock);
              }
              if (HasIv) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(Iv);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(KeyControl other) {
              if (other == null) {
                return;
              }
              if (other.HasKeyControlBlock) {
                KeyControlBlock = other.KeyControlBlock;
              }
              if (other.HasIv) {
                Iv = other.Iv;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    KeyControlBlock = input.ReadBytes();
                    break;
                  }
                  case 18: {
                    Iv = input.ReadBytes();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    KeyControlBlock = input.ReadBytes();
                    break;
                  }
                  case 18: {
                    Iv = input.ReadBytes();
                    break;
                  }
                }
              }
            }
            #endif

          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class OutputProtection : pb::IMessage<OutputProtection>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<OutputProtection> _parser = new pb::MessageParser<OutputProtection>(() => new OutputProtection());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<OutputProtection> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OutputProtection() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OutputProtection(OutputProtection other) : this() {
              _hasBits0 = other._hasBits0;
              hdcp_ = other.hdcp_;
              cgmsFlags_ = other.cgmsFlags_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OutputProtection Clone() {
              return new OutputProtection(this);
            }

            /// <summary>Field number for the "hdcp" field.</summary>
            public const int HdcpFieldNumber = 1;
            private readonly static global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP HdcpDefaultValue = global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP.None;

            private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP hdcp_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP Hdcp {
              get { if ((_hasBits0 & 1) != 0) { return hdcp_; } else { return HdcpDefaultValue; } }
              set {
                _hasBits0 |= 1;
                hdcp_ = value;
              }
            }
            /// <summary>Gets whether the "hdcp" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasHdcp {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "hdcp" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearHdcp() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "cgms_flags" field.</summary>
            public const int CgmsFlagsFieldNumber = 2;
            private readonly static global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS CgmsFlagsDefaultValue = global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS.None;

            private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS cgmsFlags_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS CgmsFlags {
              get { if ((_hasBits0 & 2) != 0) { return cgmsFlags_; } else { return CgmsFlagsDefaultValue; } }
              set {
                _hasBits0 |= 2;
                cgmsFlags_ = value;
              }
            }
            /// <summary>Gets whether the "cgms_flags" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasCgmsFlags {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "cgms_flags" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearCgmsFlags() {
              _hasBits0 &= ~2;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as OutputProtection);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(OutputProtection other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Hdcp != other.Hdcp) return false;
              if (CgmsFlags != other.CgmsFlags) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasHdcp) hash ^= Hdcp.GetHashCode();
              if (HasCgmsFlags) hash ^= CgmsFlags.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasHdcp) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Hdcp);
              }
              if (HasCgmsFlags) {
                output.WriteRawTag(16);
                output.WriteEnum((int) CgmsFlags);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasHdcp) {
                output.WriteRawTag(8);
                output.WriteEnum((int) Hdcp);
              }
              if (HasCgmsFlags) {
                output.WriteRawTag(16);
                output.WriteEnum((int) CgmsFlags);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasHdcp) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Hdcp);
              }
              if (HasCgmsFlags) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CgmsFlags);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(OutputProtection other) {
              if (other == null) {
                return;
              }
              if (other.HasHdcp) {
                Hdcp = other.Hdcp;
              }
              if (other.HasCgmsFlags) {
                CgmsFlags = other.CgmsFlags;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    Hdcp = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    CgmsFlags = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS) input.ReadEnum();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    Hdcp = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.HDCP) input.ReadEnum();
                    break;
                  }
                  case 16: {
                    CgmsFlags = (global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection.Types.CGMS) input.ReadEnum();
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the OutputProtection message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              /// Indicates whether HDCP is required on digital outputs, and which
              /// version should be used.
              /// </summary>
              public enum HDCP {
                [pbr::OriginalName("HDCP_NONE")] None = 0,
                [pbr::OriginalName("HDCP_V1")] V1 = 1,
                [pbr::OriginalName("HDCP_V2")] V2 = 2,
                [pbr::OriginalName("HDCP_V2_1")] V21 = 3,
                [pbr::OriginalName("HDCP_V2_2")] V22 = 4,
                [pbr::OriginalName("HDCP_NO_DIGITAL_OUTPUT")] NoDigitalOutput = 255,
              }

              /// <summary>
              /// Indicate the CGMS setting to be inserted on analog output.
              /// </summary>
              public enum CGMS {
                [pbr::OriginalName("CGMS_NONE")] None = 42,
                [pbr::OriginalName("COPY_FREE")] CopyFree = 0,
                [pbr::OriginalName("COPY_ONCE")] CopyOnce = 2,
                [pbr::OriginalName("COPY_NEVER")] CopyNever = 3,
              }

            }
            #endregion

          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class VideoResolutionConstraint : pb::IMessage<VideoResolutionConstraint>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<VideoResolutionConstraint> _parser = new pb::MessageParser<VideoResolutionConstraint>(() => new VideoResolutionConstraint());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<VideoResolutionConstraint> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public VideoResolutionConstraint() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public VideoResolutionConstraint(VideoResolutionConstraint other) : this() {
              _hasBits0 = other._hasBits0;
              minResolutionPixels_ = other.minResolutionPixels_;
              maxResolutionPixels_ = other.maxResolutionPixels_;
              requiredProtection_ = other.requiredProtection_ != null ? other.requiredProtection_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public VideoResolutionConstraint Clone() {
              return new VideoResolutionConstraint(this);
            }

            /// <summary>Field number for the "min_resolution_pixels" field.</summary>
            public const int MinResolutionPixelsFieldNumber = 1;
            private readonly static uint MinResolutionPixelsDefaultValue = 0;

            private uint minResolutionPixels_;
            /// <summary>
            /// Minimum and maximum video resolutions in the range (height x width).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint MinResolutionPixels {
              get { if ((_hasBits0 & 1) != 0) { return minResolutionPixels_; } else { return MinResolutionPixelsDefaultValue; } }
              set {
                _hasBits0 |= 1;
                minResolutionPixels_ = value;
              }
            }
            /// <summary>Gets whether the "min_resolution_pixels" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasMinResolutionPixels {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "min_resolution_pixels" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearMinResolutionPixels() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "max_resolution_pixels" field.</summary>
            public const int MaxResolutionPixelsFieldNumber = 2;
            private readonly static uint MaxResolutionPixelsDefaultValue = 0;

            private uint maxResolutionPixels_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public uint MaxResolutionPixels {
              get { if ((_hasBits0 & 2) != 0) { return maxResolutionPixels_; } else { return MaxResolutionPixelsDefaultValue; } }
              set {
                _hasBits0 |= 2;
                maxResolutionPixels_ = value;
              }
            }
            /// <summary>Gets whether the "max_resolution_pixels" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasMaxResolutionPixels {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "max_resolution_pixels" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearMaxResolutionPixels() {
              _hasBits0 &= ~2;
            }

            /// <summary>Field number for the "required_protection" field.</summary>
            public const int RequiredProtectionFieldNumber = 3;
            private global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection requiredProtection_;
            /// <summary>
            /// Optional output protection requirements for this range. If not
            /// specified, the OutputProtection in the KeyContainer applies.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection RequiredProtection {
              get { return requiredProtection_; }
              set {
                requiredProtection_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as VideoResolutionConstraint);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(VideoResolutionConstraint other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (MinResolutionPixels != other.MinResolutionPixels) return false;
              if (MaxResolutionPixels != other.MaxResolutionPixels) return false;
              if (!object.Equals(RequiredProtection, other.RequiredProtection)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasMinResolutionPixels) hash ^= MinResolutionPixels.GetHashCode();
              if (HasMaxResolutionPixels) hash ^= MaxResolutionPixels.GetHashCode();
              if (requiredProtection_ != null) hash ^= RequiredProtection.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasMinResolutionPixels) {
                output.WriteRawTag(8);
                output.WriteUInt32(MinResolutionPixels);
              }
              if (HasMaxResolutionPixels) {
                output.WriteRawTag(16);
                output.WriteUInt32(MaxResolutionPixels);
              }
              if (requiredProtection_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(RequiredProtection);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasMinResolutionPixels) {
                output.WriteRawTag(8);
                output.WriteUInt32(MinResolutionPixels);
              }
              if (HasMaxResolutionPixels) {
                output.WriteRawTag(16);
                output.WriteUInt32(MaxResolutionPixels);
              }
              if (requiredProtection_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(RequiredProtection);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasMinResolutionPixels) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinResolutionPixels);
              }
              if (HasMaxResolutionPixels) {
                size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxResolutionPixels);
              }
              if (requiredProtection_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequiredProtection);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(VideoResolutionConstraint other) {
              if (other == null) {
                return;
              }
              if (other.HasMinResolutionPixels) {
                MinResolutionPixels = other.MinResolutionPixels;
              }
              if (other.HasMaxResolutionPixels) {
                MaxResolutionPixels = other.MaxResolutionPixels;
              }
              if (other.requiredProtection_ != null) {
                if (requiredProtection_ == null) {
                  RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                }
                RequiredProtection.MergeFrom(other.RequiredProtection);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    MinResolutionPixels = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    MaxResolutionPixels = input.ReadUInt32();
                    break;
                  }
                  case 26: {
                    if (requiredProtection_ == null) {
                      RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                    }
                    input.ReadMessage(RequiredProtection);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    MinResolutionPixels = input.ReadUInt32();
                    break;
                  }
                  case 16: {
                    MaxResolutionPixels = input.ReadUInt32();
                    break;
                  }
                  case 26: {
                    if (requiredProtection_ == null) {
                      RequiredProtection = new global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Types.OutputProtection();
                    }
                    input.ReadMessage(RequiredProtection);
                    break;
                  }
                }
              }
            }
            #endif

          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class OperatorSessionKeyPermissions : pb::IMessage<OperatorSessionKeyPermissions>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<OperatorSessionKeyPermissions> _parser = new pb::MessageParser<OperatorSessionKeyPermissions>(() => new OperatorSessionKeyPermissions());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<OperatorSessionKeyPermissions> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.License.Types.KeyContainer.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OperatorSessionKeyPermissions() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OperatorSessionKeyPermissions(OperatorSessionKeyPermissions other) : this() {
              _hasBits0 = other._hasBits0;
              allowEncrypt_ = other.allowEncrypt_;
              allowDecrypt_ = other.allowDecrypt_;
              allowSign_ = other.allowSign_;
              allowSignatureVerify_ = other.allowSignatureVerify_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public OperatorSessionKeyPermissions Clone() {
              return new OperatorSessionKeyPermissions(this);
            }

            /// <summary>Field number for the "allow_encrypt" field.</summary>
            public const int AllowEncryptFieldNumber = 1;
            private readonly static bool AllowEncryptDefaultValue = false;

            private bool allowEncrypt_;
            /// <summary>
            /// Permissions/key usage flags for operator service keys
            /// (type = OPERATOR_SESSION).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowEncrypt {
              get { if ((_hasBits0 & 1) != 0) { return allowEncrypt_; } else { return AllowEncryptDefaultValue; } }
              set {
                _hasBits0 |= 1;
                allowEncrypt_ = value;
              }
            }
            /// <summary>Gets whether the "allow_encrypt" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAllowEncrypt {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "allow_encrypt" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAllowEncrypt() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "allow_decrypt" field.</summary>
            public const int AllowDecryptFieldNumber = 2;
            private readonly static bool AllowDecryptDefaultValue = false;

            private bool allowDecrypt_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowDecrypt {
              get { if ((_hasBits0 & 2) != 0) { return allowDecrypt_; } else { return AllowDecryptDefaultValue; } }
              set {
                _hasBits0 |= 2;
                allowDecrypt_ = value;
              }
            }
            /// <summary>Gets whether the "allow_decrypt" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAllowDecrypt {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "allow_decrypt" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAllowDecrypt() {
              _hasBits0 &= ~2;
            }

            /// <summary>Field number for the "allow_sign" field.</summary>
            public const int AllowSignFieldNumber = 3;
            private readonly static bool AllowSignDefaultValue = false;

            private bool allowSign_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowSign {
              get { if ((_hasBits0 & 4) != 0) { return allowSign_; } else { return AllowSignDefaultValue; } }
              set {
                _hasBits0 |= 4;
                allowSign_ = value;
              }
            }
            /// <summary>Gets whether the "allow_sign" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAllowSign {
              get { return (_hasBits0 & 4) != 0; }
            }
            /// <summary>Clears the value of the "allow_sign" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAllowSign() {
              _hasBits0 &= ~4;
            }

            /// <summary>Field number for the "allow_signature_verify" field.</summary>
            public const int AllowSignatureVerifyFieldNumber = 4;
            private readonly static bool AllowSignatureVerifyDefaultValue = false;

            private bool allowSignatureVerify_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool AllowSignatureVerify {
              get { if ((_hasBits0 & 8) != 0) { return allowSignatureVerify_; } else { return AllowSignatureVerifyDefaultValue; } }
              set {
                _hasBits0 |= 8;
                allowSignatureVerify_ = value;
              }
            }
            /// <summary>Gets whether the "allow_signature_verify" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasAllowSignatureVerify {
              get { return (_hasBits0 & 8) != 0; }
            }
            /// <summary>Clears the value of the "allow_signature_verify" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearAllowSignatureVerify() {
              _hasBits0 &= ~8;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as OperatorSessionKeyPermissions);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(OperatorSessionKeyPermissions other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (AllowEncrypt != other.AllowEncrypt) return false;
              if (AllowDecrypt != other.AllowDecrypt) return false;
              if (AllowSign != other.AllowSign) return false;
              if (AllowSignatureVerify != other.AllowSignatureVerify) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasAllowEncrypt) hash ^= AllowEncrypt.GetHashCode();
              if (HasAllowDecrypt) hash ^= AllowDecrypt.GetHashCode();
              if (HasAllowSign) hash ^= AllowSign.GetHashCode();
              if (HasAllowSignatureVerify) hash ^= AllowSignatureVerify.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasAllowEncrypt) {
                output.WriteRawTag(8);
                output.WriteBool(AllowEncrypt);
              }
              if (HasAllowDecrypt) {
                output.WriteRawTag(16);
                output.WriteBool(AllowDecrypt);
              }
              if (HasAllowSign) {
                output.WriteRawTag(24);
                output.WriteBool(AllowSign);
              }
              if (HasAllowSignatureVerify) {
                output.WriteRawTag(32);
                output.WriteBool(AllowSignatureVerify);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasAllowEncrypt) {
                output.WriteRawTag(8);
                output.WriteBool(AllowEncrypt);
              }
              if (HasAllowDecrypt) {
                output.WriteRawTag(16);
                output.WriteBool(AllowDecrypt);
              }
              if (HasAllowSign) {
                output.WriteRawTag(24);
                output.WriteBool(AllowSign);
              }
              if (HasAllowSignatureVerify) {
                output.WriteRawTag(32);
                output.WriteBool(AllowSignatureVerify);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasAllowEncrypt) {
                size += 1 + 1;
              }
              if (HasAllowDecrypt) {
                size += 1 + 1;
              }
              if (HasAllowSign) {
                size += 1 + 1;
              }
              if (HasAllowSignatureVerify) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(OperatorSessionKeyPermissions other) {
              if (other == null) {
                return;
              }
              if (other.HasAllowEncrypt) {
                AllowEncrypt = other.AllowEncrypt;
              }
              if (other.HasAllowDecrypt) {
                AllowDecrypt = other.AllowDecrypt;
              }
              if (other.HasAllowSign) {
                AllowSign = other.AllowSign;
              }
              if (other.HasAllowSignatureVerify) {
                AllowSignatureVerify = other.AllowSignatureVerify;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    AllowEncrypt = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowDecrypt = input.ReadBool();
                    break;
                  }
                  case 24: {
                    AllowSign = input.ReadBool();
                    break;
                  }
                  case 32: {
                    AllowSignatureVerify = input.ReadBool();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    AllowEncrypt = input.ReadBool();
                    break;
                  }
                  case 16: {
                    AllowDecrypt = input.ReadBool();
                    break;
                  }
                  case 24: {
                    AllowSign = input.ReadBool();
                    break;
                  }
                  case 32: {
                    AllowSignatureVerify = input.ReadBool();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LicenseRequest : pb::IMessage<LicenseRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicenseRequest> _parser = new pb::MessageParser<LicenseRequest>(() => new LicenseRequest());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicenseRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseRequest(LicenseRequest other) : this() {
      _hasBits0 = other._hasBits0;
      clientId_ = other.clientId_ != null ? other.clientId_.Clone() : null;
      contentId_ = other.contentId_ != null ? other.contentId_.Clone() : null;
      type_ = other.type_;
      requestTime_ = other.requestTime_;
      keyControlNonceDeprecated_ = other.keyControlNonceDeprecated_;
      protocolVersion_ = other.protocolVersion_;
      keyControlNonce_ = other.keyControlNonce_;
      encryptedClientId_ = other.encryptedClientId_ != null ? other.encryptedClientId_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseRequest Clone() {
      return new LicenseRequest(this);
    }

    /// <summary>Field number for the "client_id" field.</summary>
    public const int ClientIdFieldNumber = 1;
    private global::AAXClean.Widevine.Provisioning.ClientIdentification clientId_;
    /// <summary>
    /// The client_id provides information authenticating the calling device.  It
    /// contains the Widevine keybox token that was installed on the device at the
    /// factory.  This field or encrypted_client_id below is required for a valid
    /// license request, but both should never be present in the same request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ClientIdentification ClientId {
      get { return clientId_; }
      set {
        clientId_ = value;
      }
    }

    /// <summary>Field number for the "content_id" field.</summary>
    public const int ContentIdFieldNumber = 2;
    private global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification contentId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification ContentId {
      get { return contentId_; }
      set {
        contentId_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private readonly static global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType.New;

    private global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "request_time" field.</summary>
    public const int RequestTimeFieldNumber = 4;
    private readonly static long RequestTimeDefaultValue = 0L;

    private long requestTime_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RequestTime {
      get { if ((_hasBits0 & 2) != 0) { return requestTime_; } else { return RequestTimeDefaultValue; } }
      set {
        _hasBits0 |= 2;
        requestTime_ = value;
      }
    }
    /// <summary>Gets whether the "request_time" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRequestTime {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "request_time" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRequestTime() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "key_control_nonce_deprecated" field.</summary>
    public const int KeyControlNonceDeprecatedFieldNumber = 5;
    private readonly static pb::ByteString KeyControlNonceDeprecatedDefaultValue = pb::ByteString.Empty;

    private pb::ByteString keyControlNonceDeprecated_;
    /// <summary>
    /// Old-style decimal-encoded string key control nonce.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString KeyControlNonceDeprecated {
      get { return keyControlNonceDeprecated_ ?? KeyControlNonceDeprecatedDefaultValue; }
      set {
        keyControlNonceDeprecated_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key_control_nonce_deprecated" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyControlNonceDeprecated {
      get { return keyControlNonceDeprecated_ != null; }
    }
    /// <summary>Clears the value of the "key_control_nonce_deprecated" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyControlNonceDeprecated() {
      keyControlNonceDeprecated_ = null;
    }

    /// <summary>Field number for the "protocol_version" field.</summary>
    public const int ProtocolVersionFieldNumber = 6;
    private readonly static global::AAXClean.Widevine.Provisioning.ProtocolVersion ProtocolVersionDefaultValue = global::AAXClean.Widevine.Provisioning.ProtocolVersion.Version20;

    private global::AAXClean.Widevine.Provisioning.ProtocolVersion protocolVersion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ProtocolVersion ProtocolVersion {
      get { if ((_hasBits0 & 4) != 0) { return protocolVersion_; } else { return ProtocolVersionDefaultValue; } }
      set {
        _hasBits0 |= 4;
        protocolVersion_ = value;
      }
    }
    /// <summary>Gets whether the "protocol_version" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocolVersion {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "protocol_version" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocolVersion() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "key_control_nonce" field.</summary>
    public const int KeyControlNonceFieldNumber = 7;
    private readonly static uint KeyControlNonceDefaultValue = 0;

    private uint keyControlNonce_;
    /// <summary>
    /// New-style uint32 key control nonce, please use instead of
    /// key_control_nonce_deprecated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint KeyControlNonce {
      get { if ((_hasBits0 & 8) != 0) { return keyControlNonce_; } else { return KeyControlNonceDefaultValue; } }
      set {
        _hasBits0 |= 8;
        keyControlNonce_ = value;
      }
    }
    /// <summary>Gets whether the "key_control_nonce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyControlNonce {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "key_control_nonce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyControlNonce() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "encrypted_client_id" field.</summary>
    public const int EncryptedClientIdFieldNumber = 8;
    private global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification encryptedClientId_;
    /// <summary>
    /// Encrypted ClientIdentification message, used for privacy purposes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification EncryptedClientId {
      get { return encryptedClientId_; }
      set {
        encryptedClientId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicenseRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicenseRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ClientId, other.ClientId)) return false;
      if (!object.Equals(ContentId, other.ContentId)) return false;
      if (Type != other.Type) return false;
      if (RequestTime != other.RequestTime) return false;
      if (KeyControlNonceDeprecated != other.KeyControlNonceDeprecated) return false;
      if (ProtocolVersion != other.ProtocolVersion) return false;
      if (KeyControlNonce != other.KeyControlNonce) return false;
      if (!object.Equals(EncryptedClientId, other.EncryptedClientId)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (clientId_ != null) hash ^= ClientId.GetHashCode();
      if (contentId_ != null) hash ^= ContentId.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasRequestTime) hash ^= RequestTime.GetHashCode();
      if (HasKeyControlNonceDeprecated) hash ^= KeyControlNonceDeprecated.GetHashCode();
      if (HasProtocolVersion) hash ^= ProtocolVersion.GetHashCode();
      if (HasKeyControlNonce) hash ^= KeyControlNonce.GetHashCode();
      if (encryptedClientId_ != null) hash ^= EncryptedClientId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (clientId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientId);
      }
      if (contentId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ContentId);
      }
      if (HasType) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      if (HasRequestTime) {
        output.WriteRawTag(32);
        output.WriteInt64(RequestTime);
      }
      if (HasKeyControlNonceDeprecated) {
        output.WriteRawTag(42);
        output.WriteBytes(KeyControlNonceDeprecated);
      }
      if (HasProtocolVersion) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ProtocolVersion);
      }
      if (HasKeyControlNonce) {
        output.WriteRawTag(56);
        output.WriteUInt32(KeyControlNonce);
      }
      if (encryptedClientId_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(EncryptedClientId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (clientId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientId);
      }
      if (contentId_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ContentId);
      }
      if (HasType) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      if (HasRequestTime) {
        output.WriteRawTag(32);
        output.WriteInt64(RequestTime);
      }
      if (HasKeyControlNonceDeprecated) {
        output.WriteRawTag(42);
        output.WriteBytes(KeyControlNonceDeprecated);
      }
      if (HasProtocolVersion) {
        output.WriteRawTag(48);
        output.WriteEnum((int) ProtocolVersion);
      }
      if (HasKeyControlNonce) {
        output.WriteRawTag(56);
        output.WriteUInt32(KeyControlNonce);
      }
      if (encryptedClientId_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(EncryptedClientId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (clientId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientId);
      }
      if (contentId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ContentId);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasRequestTime) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RequestTime);
      }
      if (HasKeyControlNonceDeprecated) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(KeyControlNonceDeprecated);
      }
      if (HasProtocolVersion) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolVersion);
      }
      if (HasKeyControlNonce) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(KeyControlNonce);
      }
      if (encryptedClientId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EncryptedClientId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicenseRequest other) {
      if (other == null) {
        return;
      }
      if (other.clientId_ != null) {
        if (clientId_ == null) {
          ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
        }
        ClientId.MergeFrom(other.ClientId);
      }
      if (other.contentId_ != null) {
        if (contentId_ == null) {
          ContentId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification();
        }
        ContentId.MergeFrom(other.ContentId);
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasRequestTime) {
        RequestTime = other.RequestTime;
      }
      if (other.HasKeyControlNonceDeprecated) {
        KeyControlNonceDeprecated = other.KeyControlNonceDeprecated;
      }
      if (other.HasProtocolVersion) {
        ProtocolVersion = other.ProtocolVersion;
      }
      if (other.HasKeyControlNonce) {
        KeyControlNonce = other.KeyControlNonce;
      }
      if (other.encryptedClientId_ != null) {
        if (encryptedClientId_ == null) {
          EncryptedClientId = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
        }
        EncryptedClientId.MergeFrom(other.EncryptedClientId);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (clientId_ == null) {
              ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
            }
            input.ReadMessage(ClientId);
            break;
          }
          case 18: {
            if (contentId_ == null) {
              ContentId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification();
            }
            input.ReadMessage(ContentId);
            break;
          }
          case 24: {
            Type = (global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType) input.ReadEnum();
            break;
          }
          case 32: {
            RequestTime = input.ReadInt64();
            break;
          }
          case 42: {
            KeyControlNonceDeprecated = input.ReadBytes();
            break;
          }
          case 48: {
            ProtocolVersion = (global::AAXClean.Widevine.Provisioning.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 56: {
            KeyControlNonce = input.ReadUInt32();
            break;
          }
          case 66: {
            if (encryptedClientId_ == null) {
              EncryptedClientId = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
            }
            input.ReadMessage(EncryptedClientId);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (clientId_ == null) {
              ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
            }
            input.ReadMessage(ClientId);
            break;
          }
          case 18: {
            if (contentId_ == null) {
              ContentId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification();
            }
            input.ReadMessage(ContentId);
            break;
          }
          case 24: {
            Type = (global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.RequestType) input.ReadEnum();
            break;
          }
          case 32: {
            RequestTime = input.ReadInt64();
            break;
          }
          case 42: {
            KeyControlNonceDeprecated = input.ReadBytes();
            break;
          }
          case 48: {
            ProtocolVersion = (global::AAXClean.Widevine.Provisioning.ProtocolVersion) input.ReadEnum();
            break;
          }
          case 56: {
            KeyControlNonce = input.ReadUInt32();
            break;
          }
          case 66: {
            if (encryptedClientId_ == null) {
              EncryptedClientId = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
            }
            input.ReadMessage(EncryptedClientId);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LicenseRequest message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum RequestType {
        [pbr::OriginalName("NEW")] New = 1,
        [pbr::OriginalName("RENEWAL")] Renewal = 2,
        [pbr::OriginalName("RELEASE")] Release = 3,
      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ContentIdentification : pb::IMessage<ContentIdentification>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ContentIdentification> _parser = new pb::MessageParser<ContentIdentification>(() => new ContentIdentification());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ContentIdentification> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AAXClean.Widevine.Provisioning.LicenseRequest.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ContentIdentification() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ContentIdentification(ContentIdentification other) : this() {
          cencId_ = other.cencId_ != null ? other.cencId_.Clone() : null;
          webmId_ = other.webmId_ != null ? other.webmId_.Clone() : null;
          license_ = other.license_ != null ? other.license_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ContentIdentification Clone() {
          return new ContentIdentification(this);
        }

        /// <summary>Field number for the "cenc_id" field.</summary>
        public const int CencIdFieldNumber = 1;
        private global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC cencId_;
        /// <summary>
        /// Exactly one of these must be present.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC CencId {
          get { return cencId_; }
          set {
            cencId_ = value;
          }
        }

        /// <summary>Field number for the "webm_id" field.</summary>
        public const int WebmIdFieldNumber = 2;
        private global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM webmId_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM WebmId {
          get { return webmId_; }
          set {
            webmId_ = value;
          }
        }

        /// <summary>Field number for the "license" field.</summary>
        public const int LicenseFieldNumber = 3;
        private global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense license_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense License {
          get { return license_; }
          set {
            license_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ContentIdentification);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ContentIdentification other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(CencId, other.CencId)) return false;
          if (!object.Equals(WebmId, other.WebmId)) return false;
          if (!object.Equals(License, other.License)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (cencId_ != null) hash ^= CencId.GetHashCode();
          if (webmId_ != null) hash ^= WebmId.GetHashCode();
          if (license_ != null) hash ^= License.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (cencId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(CencId);
          }
          if (webmId_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(WebmId);
          }
          if (license_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(License);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (cencId_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(CencId);
          }
          if (webmId_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(WebmId);
          }
          if (license_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(License);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (cencId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CencId);
          }
          if (webmId_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(WebmId);
          }
          if (license_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(License);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ContentIdentification other) {
          if (other == null) {
            return;
          }
          if (other.cencId_ != null) {
            if (cencId_ == null) {
              CencId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC();
            }
            CencId.MergeFrom(other.CencId);
          }
          if (other.webmId_ != null) {
            if (webmId_ == null) {
              WebmId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM();
            }
            WebmId.MergeFrom(other.WebmId);
          }
          if (other.license_ != null) {
            if (license_ == null) {
              License = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
            }
            License.MergeFrom(other.License);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (cencId_ == null) {
                  CencId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC();
                }
                input.ReadMessage(CencId);
                break;
              }
              case 18: {
                if (webmId_ == null) {
                  WebmId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM();
                }
                input.ReadMessage(WebmId);
                break;
              }
              case 26: {
                if (license_ == null) {
                  License = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
                }
                input.ReadMessage(License);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                if (cencId_ == null) {
                  CencId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.CENC();
                }
                input.ReadMessage(CencId);
                break;
              }
              case 18: {
                if (webmId_ == null) {
                  WebmId = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.WebM();
                }
                input.ReadMessage(WebmId);
                break;
              }
              case 26: {
                if (license_ == null) {
                  License = new global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Types.ExistingLicense();
                }
                input.ReadMessage(License);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ContentIdentification message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class CENC : pb::IMessage<CENC>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<CENC> _parser = new pb::MessageParser<CENC>(() => new CENC());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<CENC> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public CENC() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public CENC(CENC other) : this() {
              _hasBits0 = other._hasBits0;
              pssh_ = other.pssh_.Clone();
              licenseType_ = other.licenseType_;
              requestId_ = other.requestId_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public CENC Clone() {
              return new CENC(this);
            }

            /// <summary>Field number for the "pssh" field.</summary>
            public const int PsshFieldNumber = 1;
            private static readonly pb::FieldCodec<pb::ByteString> _repeated_pssh_codec
                = pb::FieldCodec.ForBytes(10);
            private readonly pbc::RepeatedField<pb::ByteString> pssh_ = new pbc::RepeatedField<pb::ByteString>();
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::RepeatedField<pb::ByteString> Pssh {
              get { return pssh_; }
            }

            /// <summary>Field number for the "license_type" field.</summary>
            public const int LicenseTypeFieldNumber = 2;
            private readonly static global::AAXClean.Widevine.Provisioning.LicenseType LicenseTypeDefaultValue = global::AAXClean.Widevine.Provisioning.LicenseType.Streaming;

            private global::AAXClean.Widevine.Provisioning.LicenseType licenseType_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.LicenseType LicenseType {
              get { if ((_hasBits0 & 1) != 0) { return licenseType_; } else { return LicenseTypeDefaultValue; } }
              set {
                _hasBits0 |= 1;
                licenseType_ = value;
              }
            }
            /// <summary>Gets whether the "license_type" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasLicenseType {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "license_type" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearLicenseType() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "request_id" field.</summary>
            public const int RequestIdFieldNumber = 3;
            private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

            private pb::ByteString requestId_;
            /// <summary>
            /// Opaque, client-specified.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString RequestId {
              get { return requestId_ ?? RequestIdDefaultValue; }
              set {
                requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "request_id" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasRequestId {
              get { return requestId_ != null; }
            }
            /// <summary>Clears the value of the "request_id" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearRequestId() {
              requestId_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as CENC);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(CENC other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!pssh_.Equals(other.pssh_)) return false;
              if (LicenseType != other.LicenseType) return false;
              if (RequestId != other.RequestId) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= pssh_.GetHashCode();
              if (HasLicenseType) hash ^= LicenseType.GetHashCode();
              if (HasRequestId) hash ^= RequestId.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              pssh_.WriteTo(output, _repeated_pssh_codec);
              if (HasLicenseType) {
                output.WriteRawTag(16);
                output.WriteEnum((int) LicenseType);
              }
              if (HasRequestId) {
                output.WriteRawTag(26);
                output.WriteBytes(RequestId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              pssh_.WriteTo(ref output, _repeated_pssh_codec);
              if (HasLicenseType) {
                output.WriteRawTag(16);
                output.WriteEnum((int) LicenseType);
              }
              if (HasRequestId) {
                output.WriteRawTag(26);
                output.WriteBytes(RequestId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              size += pssh_.CalculateSize(_repeated_pssh_codec);
              if (HasLicenseType) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicenseType);
              }
              if (HasRequestId) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(CENC other) {
              if (other == null) {
                return;
              }
              pssh_.Add(other.pssh_);
              if (other.HasLicenseType) {
                LicenseType = other.LicenseType;
              }
              if (other.HasRequestId) {
                RequestId = other.RequestId;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    pssh_.AddEntriesFrom(input, _repeated_pssh_codec);
                    break;
                  }
                  case 16: {
                    LicenseType = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    RequestId = input.ReadBytes();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    pssh_.AddEntriesFrom(ref input, _repeated_pssh_codec);
                    break;
                  }
                  case 16: {
                    LicenseType = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    RequestId = input.ReadBytes();
                    break;
                  }
                }
              }
            }
            #endif

          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class WebM : pb::IMessage<WebM>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<WebM> _parser = new pb::MessageParser<WebM>(() => new WebM());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<WebM> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public WebM() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public WebM(WebM other) : this() {
              _hasBits0 = other._hasBits0;
              header_ = other.header_;
              licenseType_ = other.licenseType_;
              requestId_ = other.requestId_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public WebM Clone() {
              return new WebM(this);
            }

            /// <summary>Field number for the "header" field.</summary>
            public const int HeaderFieldNumber = 1;
            private readonly static pb::ByteString HeaderDefaultValue = pb::ByteString.Empty;

            private pb::ByteString header_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString Header {
              get { return header_ ?? HeaderDefaultValue; }
              set {
                header_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "header" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasHeader {
              get { return header_ != null; }
            }
            /// <summary>Clears the value of the "header" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearHeader() {
              header_ = null;
            }

            /// <summary>Field number for the "license_type" field.</summary>
            public const int LicenseTypeFieldNumber = 2;
            private readonly static global::AAXClean.Widevine.Provisioning.LicenseType LicenseTypeDefaultValue = global::AAXClean.Widevine.Provisioning.LicenseType.Streaming;

            private global::AAXClean.Widevine.Provisioning.LicenseType licenseType_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.LicenseType LicenseType {
              get { if ((_hasBits0 & 1) != 0) { return licenseType_; } else { return LicenseTypeDefaultValue; } }
              set {
                _hasBits0 |= 1;
                licenseType_ = value;
              }
            }
            /// <summary>Gets whether the "license_type" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasLicenseType {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "license_type" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearLicenseType() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "request_id" field.</summary>
            public const int RequestIdFieldNumber = 3;
            private readonly static pb::ByteString RequestIdDefaultValue = pb::ByteString.Empty;

            private pb::ByteString requestId_;
            /// <summary>
            /// Opaque, client-specified.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString RequestId {
              get { return requestId_ ?? RequestIdDefaultValue; }
              set {
                requestId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "request_id" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasRequestId {
              get { return requestId_ != null; }
            }
            /// <summary>Clears the value of the "request_id" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearRequestId() {
              requestId_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as WebM);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(WebM other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Header != other.Header) return false;
              if (LicenseType != other.LicenseType) return false;
              if (RequestId != other.RequestId) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (HasHeader) hash ^= Header.GetHashCode();
              if (HasLicenseType) hash ^= LicenseType.GetHashCode();
              if (HasRequestId) hash ^= RequestId.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (HasHeader) {
                output.WriteRawTag(10);
                output.WriteBytes(Header);
              }
              if (HasLicenseType) {
                output.WriteRawTag(16);
                output.WriteEnum((int) LicenseType);
              }
              if (HasRequestId) {
                output.WriteRawTag(26);
                output.WriteBytes(RequestId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (HasHeader) {
                output.WriteRawTag(10);
                output.WriteBytes(Header);
              }
              if (HasLicenseType) {
                output.WriteRawTag(16);
                output.WriteEnum((int) LicenseType);
              }
              if (HasRequestId) {
                output.WriteRawTag(26);
                output.WriteBytes(RequestId);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (HasHeader) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(Header);
              }
              if (HasLicenseType) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LicenseType);
              }
              if (HasRequestId) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(RequestId);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(WebM other) {
              if (other == null) {
                return;
              }
              if (other.HasHeader) {
                Header = other.Header;
              }
              if (other.HasLicenseType) {
                LicenseType = other.LicenseType;
              }
              if (other.HasRequestId) {
                RequestId = other.RequestId;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Header = input.ReadBytes();
                    break;
                  }
                  case 16: {
                    LicenseType = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    RequestId = input.ReadBytes();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Header = input.ReadBytes();
                    break;
                  }
                  case 16: {
                    LicenseType = (global::AAXClean.Widevine.Provisioning.LicenseType) input.ReadEnum();
                    break;
                  }
                  case 26: {
                    RequestId = input.ReadBytes();
                    break;
                  }
                }
              }
            }
            #endif

          }

          [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
          public sealed partial class ExistingLicense : pb::IMessage<ExistingLicense>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<ExistingLicense> _parser = new pb::MessageParser<ExistingLicense>(() => new ExistingLicense());
            private pb::UnknownFieldSet _unknownFields;
            private int _hasBits0;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<ExistingLicense> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::AAXClean.Widevine.Provisioning.LicenseRequest.Types.ContentIdentification.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExistingLicense() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExistingLicense(ExistingLicense other) : this() {
              _hasBits0 = other._hasBits0;
              licenseId_ = other.licenseId_ != null ? other.licenseId_.Clone() : null;
              secondsSinceStarted_ = other.secondsSinceStarted_;
              secondsSinceLastPlayed_ = other.secondsSinceLastPlayed_;
              sessionUsageTableEntry_ = other.sessionUsageTableEntry_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public ExistingLicense Clone() {
              return new ExistingLicense(this);
            }

            /// <summary>Field number for the "license_id" field.</summary>
            public const int LicenseIdFieldNumber = 1;
            private global::AAXClean.Widevine.Provisioning.LicenseIdentification licenseId_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::AAXClean.Widevine.Provisioning.LicenseIdentification LicenseId {
              get { return licenseId_; }
              set {
                licenseId_ = value;
              }
            }

            /// <summary>Field number for the "seconds_since_started" field.</summary>
            public const int SecondsSinceStartedFieldNumber = 2;
            private readonly static long SecondsSinceStartedDefaultValue = 0L;

            private long secondsSinceStarted_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public long SecondsSinceStarted {
              get { if ((_hasBits0 & 1) != 0) { return secondsSinceStarted_; } else { return SecondsSinceStartedDefaultValue; } }
              set {
                _hasBits0 |= 1;
                secondsSinceStarted_ = value;
              }
            }
            /// <summary>Gets whether the "seconds_since_started" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasSecondsSinceStarted {
              get { return (_hasBits0 & 1) != 0; }
            }
            /// <summary>Clears the value of the "seconds_since_started" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearSecondsSinceStarted() {
              _hasBits0 &= ~1;
            }

            /// <summary>Field number for the "seconds_since_last_played" field.</summary>
            public const int SecondsSinceLastPlayedFieldNumber = 3;
            private readonly static long SecondsSinceLastPlayedDefaultValue = 0L;

            private long secondsSinceLastPlayed_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public long SecondsSinceLastPlayed {
              get { if ((_hasBits0 & 2) != 0) { return secondsSinceLastPlayed_; } else { return SecondsSinceLastPlayedDefaultValue; } }
              set {
                _hasBits0 |= 2;
                secondsSinceLastPlayed_ = value;
              }
            }
            /// <summary>Gets whether the "seconds_since_last_played" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasSecondsSinceLastPlayed {
              get { return (_hasBits0 & 2) != 0; }
            }
            /// <summary>Clears the value of the "seconds_since_last_played" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearSecondsSinceLastPlayed() {
              _hasBits0 &= ~2;
            }

            /// <summary>Field number for the "session_usage_table_entry" field.</summary>
            public const int SessionUsageTableEntryFieldNumber = 4;
            private readonly static pb::ByteString SessionUsageTableEntryDefaultValue = pb::ByteString.Empty;

            private pb::ByteString sessionUsageTableEntry_;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pb::ByteString SessionUsageTableEntry {
              get { return sessionUsageTableEntry_ ?? SessionUsageTableEntryDefaultValue; }
              set {
                sessionUsageTableEntry_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }
            /// <summary>Gets whether the "session_usage_table_entry" field is set</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool HasSessionUsageTableEntry {
              get { return sessionUsageTableEntry_ != null; }
            }
            /// <summary>Clears the value of the "session_usage_table_entry" field</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void ClearSessionUsageTableEntry() {
              sessionUsageTableEntry_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as ExistingLicense);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(ExistingLicense other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(LicenseId, other.LicenseId)) return false;
              if (SecondsSinceStarted != other.SecondsSinceStarted) return false;
              if (SecondsSinceLastPlayed != other.SecondsSinceLastPlayed) return false;
              if (SessionUsageTableEntry != other.SessionUsageTableEntry) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (licenseId_ != null) hash ^= LicenseId.GetHashCode();
              if (HasSecondsSinceStarted) hash ^= SecondsSinceStarted.GetHashCode();
              if (HasSecondsSinceLastPlayed) hash ^= SecondsSinceLastPlayed.GetHashCode();
              if (HasSessionUsageTableEntry) hash ^= SessionUsageTableEntry.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (licenseId_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(LicenseId);
              }
              if (HasSecondsSinceStarted) {
                output.WriteRawTag(16);
                output.WriteInt64(SecondsSinceStarted);
              }
              if (HasSecondsSinceLastPlayed) {
                output.WriteRawTag(24);
                output.WriteInt64(SecondsSinceLastPlayed);
              }
              if (HasSessionUsageTableEntry) {
                output.WriteRawTag(34);
                output.WriteBytes(SessionUsageTableEntry);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (licenseId_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(LicenseId);
              }
              if (HasSecondsSinceStarted) {
                output.WriteRawTag(16);
                output.WriteInt64(SecondsSinceStarted);
              }
              if (HasSecondsSinceLastPlayed) {
                output.WriteRawTag(24);
                output.WriteInt64(SecondsSinceLastPlayed);
              }
              if (HasSessionUsageTableEntry) {
                output.WriteRawTag(34);
                output.WriteBytes(SessionUsageTableEntry);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (licenseId_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(LicenseId);
              }
              if (HasSecondsSinceStarted) {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(SecondsSinceStarted);
              }
              if (HasSecondsSinceLastPlayed) {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(SecondsSinceLastPlayed);
              }
              if (HasSessionUsageTableEntry) {
                size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionUsageTableEntry);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(ExistingLicense other) {
              if (other == null) {
                return;
              }
              if (other.licenseId_ != null) {
                if (licenseId_ == null) {
                  LicenseId = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
                }
                LicenseId.MergeFrom(other.LicenseId);
              }
              if (other.HasSecondsSinceStarted) {
                SecondsSinceStarted = other.SecondsSinceStarted;
              }
              if (other.HasSecondsSinceLastPlayed) {
                SecondsSinceLastPlayed = other.SecondsSinceLastPlayed;
              }
              if (other.HasSessionUsageTableEntry) {
                SessionUsageTableEntry = other.SessionUsageTableEntry;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (licenseId_ == null) {
                      LicenseId = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
                    }
                    input.ReadMessage(LicenseId);
                    break;
                  }
                  case 16: {
                    SecondsSinceStarted = input.ReadInt64();
                    break;
                  }
                  case 24: {
                    SecondsSinceLastPlayed = input.ReadInt64();
                    break;
                  }
                  case 34: {
                    SessionUsageTableEntry = input.ReadBytes();
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
              if ((tag & 7) == 4) {
                // Abort on any end group tag.
                return;
              }
              switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    if (licenseId_ == null) {
                      LicenseId = new global::AAXClean.Widevine.Provisioning.LicenseIdentification();
                    }
                    input.ReadMessage(LicenseId);
                    break;
                  }
                  case 16: {
                    SecondsSinceStarted = input.ReadInt64();
                    break;
                  }
                  case 24: {
                    SecondsSinceLastPlayed = input.ReadInt64();
                    break;
                  }
                  case 34: {
                    SessionUsageTableEntry = input.ReadBytes();
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class LicenseError : pb::IMessage<LicenseError>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LicenseError> _parser = new pb::MessageParser<LicenseError>(() => new LicenseError());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LicenseError> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseError() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseError(LicenseError other) : this() {
      _hasBits0 = other._hasBits0;
      errorCode_ = other.errorCode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LicenseError Clone() {
      return new LicenseError(this);
    }

    /// <summary>Field number for the "error_code" field.</summary>
    public const int ErrorCodeFieldNumber = 1;
    private readonly static global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error ErrorCodeDefaultValue = global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error.InvalidDeviceCertificate;

    private global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error errorCode_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error ErrorCode {
      get { if ((_hasBits0 & 1) != 0) { return errorCode_; } else { return ErrorCodeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        errorCode_ = value;
      }
    }
    /// <summary>Gets whether the "error_code" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasErrorCode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "error_code" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearErrorCode() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LicenseError);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LicenseError other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ErrorCode != other.ErrorCode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasErrorCode) hash ^= ErrorCode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasErrorCode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasErrorCode) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ErrorCode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasErrorCode) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ErrorCode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LicenseError other) {
      if (other == null) {
        return;
      }
      if (other.HasErrorCode) {
        ErrorCode = other.ErrorCode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ErrorCode = (global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ErrorCode = (global::AAXClean.Widevine.Provisioning.LicenseError.Types.Error) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the LicenseError message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum Error {
        /// <summary>
        /// The device credentials are invalid. The device must re-provision.
        /// </summary>
        [pbr::OriginalName("INVALID_DEVICE_CERTIFICATE")] InvalidDeviceCertificate = 1,
        /// <summary>
        /// The device credentials have been revoked. Re-provisioning is not
        /// possible.
        /// </summary>
        [pbr::OriginalName("REVOKED_DEVICE_CERTIFICATE")] RevokedDeviceCertificate = 2,
        /// <summary>
        /// The service is currently unavailable due to the backend being down
        /// or similar circumstances.
        /// </summary>
        [pbr::OriginalName("SERVICE_UNAVAILABLE")] ServiceUnavailable = 3,
      }

    }
    #endregion

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class RemoteAttestation : pb::IMessage<RemoteAttestation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RemoteAttestation> _parser = new pb::MessageParser<RemoteAttestation>(() => new RemoteAttestation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RemoteAttestation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RemoteAttestation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RemoteAttestation(RemoteAttestation other) : this() {
      certificate_ = other.certificate_ != null ? other.certificate_.Clone() : null;
      salt_ = other.salt_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RemoteAttestation Clone() {
      return new RemoteAttestation(this);
    }

    /// <summary>Field number for the "certificate" field.</summary>
    public const int CertificateFieldNumber = 1;
    private global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification certificate_;
    /// <summary>
    /// Encrypted ClientIdentification message containing the device remote
    /// attestation certificate. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification Certificate {
      get { return certificate_; }
      set {
        certificate_ = value;
      }
    }

    /// <summary>Field number for the "salt" field.</summary>
    public const int SaltFieldNumber = 2;
    private readonly static pb::ByteString SaltDefaultValue = pb::ByteString.Empty;

    private pb::ByteString salt_;
    /// <summary>
    /// Bytes of salt which were added to the remote attestation challenge prior to
    /// signing it. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Salt {
      get { return salt_ ?? SaltDefaultValue; }
      set {
        salt_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "salt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSalt {
      get { return salt_ != null; }
    }
    /// <summary>Clears the value of the "salt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSalt() {
      salt_ = null;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 3;
    private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    /// <summary>
    /// Signed remote attestation challenge + salt. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RemoteAttestation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RemoteAttestation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Certificate, other.Certificate)) return false;
      if (Salt != other.Salt) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (certificate_ != null) hash ^= Certificate.GetHashCode();
      if (HasSalt) hash ^= Salt.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (certificate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Certificate);
      }
      if (HasSalt) {
        output.WriteRawTag(18);
        output.WriteBytes(Salt);
      }
      if (HasSignature) {
        output.WriteRawTag(26);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (certificate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Certificate);
      }
      if (HasSalt) {
        output.WriteRawTag(18);
        output.WriteBytes(Salt);
      }
      if (HasSignature) {
        output.WriteRawTag(26);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (certificate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Certificate);
      }
      if (HasSalt) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Salt);
      }
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RemoteAttestation other) {
      if (other == null) {
        return;
      }
      if (other.certificate_ != null) {
        if (certificate_ == null) {
          Certificate = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
        }
        Certificate.MergeFrom(other.Certificate);
      }
      if (other.HasSalt) {
        Salt = other.Salt;
      }
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (certificate_ == null) {
              Certificate = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
            }
            input.ReadMessage(Certificate);
            break;
          }
          case 18: {
            Salt = input.ReadBytes();
            break;
          }
          case 26: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (certificate_ == null) {
              Certificate = new global::AAXClean.Widevine.Provisioning.EncryptedClientIdentification();
            }
            input.ReadMessage(Certificate);
            break;
          }
          case 18: {
            Salt = input.ReadBytes();
            break;
          }
          case 26: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignedMessage : pb::IMessage<SignedMessage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignedMessage> _parser = new pb::MessageParser<SignedMessage>(() => new SignedMessage());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignedMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedMessage(SignedMessage other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      msg_ = other.msg_;
      signature_ = other.signature_;
      sessionKey_ = other.sessionKey_;
      remoteAttestation_ = other.remoteAttestation_ != null ? other.remoteAttestation_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedMessage Clone() {
      return new SignedMessage(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType.LicenseRequest;

    private global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "msg" field.</summary>
    public const int MsgFieldNumber = 2;
    private readonly static pb::ByteString MsgDefaultValue = pb::ByteString.Empty;

    private pb::ByteString msg_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Msg {
      get { return msg_ ?? MsgDefaultValue; }
      set {
        msg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "msg" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMsg {
      get { return msg_ != null; }
    }
    /// <summary>Clears the value of the "msg" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMsg() {
      msg_ = null;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 3;
    private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signature_ = null;
    }

    /// <summary>Field number for the "session_key" field.</summary>
    public const int SessionKeyFieldNumber = 4;
    private readonly static pb::ByteString SessionKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString sessionKey_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SessionKey {
      get { return sessionKey_ ?? SessionKeyDefaultValue; }
      set {
        sessionKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "session_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSessionKey {
      get { return sessionKey_ != null; }
    }
    /// <summary>Clears the value of the "session_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionKey() {
      sessionKey_ = null;
    }

    /// <summary>Field number for the "remote_attestation" field.</summary>
    public const int RemoteAttestationFieldNumber = 5;
    private global::AAXClean.Widevine.Provisioning.RemoteAttestation remoteAttestation_;
    /// <summary>
    /// Remote attestation data which will be present in the initial license
    /// request for ChromeOS client devices operating in verified mode. Remote
    /// attestation challenge data is |msg| field above. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.RemoteAttestation RemoteAttestation {
      get { return remoteAttestation_; }
      set {
        remoteAttestation_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignedMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignedMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Msg != other.Msg) return false;
      if (Signature != other.Signature) return false;
      if (SessionKey != other.SessionKey) return false;
      if (!object.Equals(RemoteAttestation, other.RemoteAttestation)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasMsg) hash ^= Msg.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (HasSessionKey) hash ^= SessionKey.GetHashCode();
      if (remoteAttestation_ != null) hash ^= RemoteAttestation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasMsg) {
        output.WriteRawTag(18);
        output.WriteBytes(Msg);
      }
      if (HasSignature) {
        output.WriteRawTag(26);
        output.WriteBytes(Signature);
      }
      if (HasSessionKey) {
        output.WriteRawTag(34);
        output.WriteBytes(SessionKey);
      }
      if (remoteAttestation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RemoteAttestation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasMsg) {
        output.WriteRawTag(18);
        output.WriteBytes(Msg);
      }
      if (HasSignature) {
        output.WriteRawTag(26);
        output.WriteBytes(Signature);
      }
      if (HasSessionKey) {
        output.WriteRawTag(34);
        output.WriteBytes(SessionKey);
      }
      if (remoteAttestation_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RemoteAttestation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasMsg) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Msg);
      }
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (HasSessionKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SessionKey);
      }
      if (remoteAttestation_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteAttestation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignedMessage other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasMsg) {
        Msg = other.Msg;
      }
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      if (other.HasSessionKey) {
        SessionKey = other.SessionKey;
      }
      if (other.remoteAttestation_ != null) {
        if (remoteAttestation_ == null) {
          RemoteAttestation = new global::AAXClean.Widevine.Provisioning.RemoteAttestation();
        }
        RemoteAttestation.MergeFrom(other.RemoteAttestation);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType) input.ReadEnum();
            break;
          }
          case 18: {
            Msg = input.ReadBytes();
            break;
          }
          case 26: {
            Signature = input.ReadBytes();
            break;
          }
          case 34: {
            SessionKey = input.ReadBytes();
            break;
          }
          case 42: {
            if (remoteAttestation_ == null) {
              RemoteAttestation = new global::AAXClean.Widevine.Provisioning.RemoteAttestation();
            }
            input.ReadMessage(RemoteAttestation);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.SignedMessage.Types.MessageType) input.ReadEnum();
            break;
          }
          case 18: {
            Msg = input.ReadBytes();
            break;
          }
          case 26: {
            Signature = input.ReadBytes();
            break;
          }
          case 34: {
            SessionKey = input.ReadBytes();
            break;
          }
          case 42: {
            if (remoteAttestation_ == null) {
              RemoteAttestation = new global::AAXClean.Widevine.Provisioning.RemoteAttestation();
            }
            input.ReadMessage(RemoteAttestation);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SignedMessage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum MessageType {
        [pbr::OriginalName("LICENSE_REQUEST")] LicenseRequest = 1,
        [pbr::OriginalName("LICENSE")] License = 2,
        [pbr::OriginalName("ERROR_RESPONSE")] ErrorResponse = 3,
        [pbr::OriginalName("SERVICE_CERTIFICATE_REQUEST")] ServiceCertificateRequest = 4,
        [pbr::OriginalName("SERVICE_CERTIFICATE")] ServiceCertificate = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// ProvisioningOptions specifies the type of certificate to specify and
  /// in the case of X509 certificates, the certificate authority to use.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ProvisioningOptions : pb::IMessage<ProvisioningOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProvisioningOptions> _parser = new pb::MessageParser<ProvisioningOptions>(() => new ProvisioningOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProvisioningOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningOptions(ProvisioningOptions other) : this() {
      _hasBits0 = other._hasBits0;
      certificateType_ = other.certificateType_;
      certificateAuthority_ = other.certificateAuthority_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningOptions Clone() {
      return new ProvisioningOptions(this);
    }

    /// <summary>Field number for the "certificate_type" field.</summary>
    public const int CertificateTypeFieldNumber = 1;
    private readonly static global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType CertificateTypeDefaultValue = global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType.WidevineDrm;

    private global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType certificateType_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType CertificateType {
      get { if ((_hasBits0 & 1) != 0) { return certificateType_; } else { return CertificateTypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        certificateType_ = value;
      }
    }
    /// <summary>Gets whether the "certificate_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCertificateType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "certificate_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCertificateType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "certificate_authority" field.</summary>
    public const int CertificateAuthorityFieldNumber = 2;
    private readonly static string CertificateAuthorityDefaultValue = "";

    private string certificateAuthority_;
    /// <summary>
    /// It is recommended that the certificate_authority specify the X.509
    /// Subject of the signing certificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CertificateAuthority {
      get { return certificateAuthority_ ?? CertificateAuthorityDefaultValue; }
      set {
        certificateAuthority_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "certificate_authority" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCertificateAuthority {
      get { return certificateAuthority_ != null; }
    }
    /// <summary>Clears the value of the "certificate_authority" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCertificateAuthority() {
      certificateAuthority_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProvisioningOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProvisioningOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CertificateType != other.CertificateType) return false;
      if (CertificateAuthority != other.CertificateAuthority) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCertificateType) hash ^= CertificateType.GetHashCode();
      if (HasCertificateAuthority) hash ^= CertificateAuthority.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCertificateType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CertificateType);
      }
      if (HasCertificateAuthority) {
        output.WriteRawTag(18);
        output.WriteString(CertificateAuthority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCertificateType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CertificateType);
      }
      if (HasCertificateAuthority) {
        output.WriteRawTag(18);
        output.WriteString(CertificateAuthority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCertificateType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CertificateType);
      }
      if (HasCertificateAuthority) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CertificateAuthority);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProvisioningOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasCertificateType) {
        CertificateType = other.CertificateType;
      }
      if (other.HasCertificateAuthority) {
        CertificateAuthority = other.CertificateAuthority;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CertificateType = (global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType) input.ReadEnum();
            break;
          }
          case 18: {
            CertificateAuthority = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CertificateType = (global::AAXClean.Widevine.Provisioning.ProvisioningOptions.Types.CertificateType) input.ReadEnum();
            break;
          }
          case 18: {
            CertificateAuthority = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ProvisioningOptions message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum CertificateType {
        /// <summary>
        /// Default.  The original certificate type.
        /// </summary>
        [pbr::OriginalName("WIDEVINE_DRM")] WidevineDrm = 0,
        /// <summary>
        /// X.509 certificate.
        /// </summary>
        [pbr::OriginalName("X509")] X509 = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// Provisioning request sent by client devices to provisioning service.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ProvisioningRequest : pb::IMessage<ProvisioningRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProvisioningRequest> _parser = new pb::MessageParser<ProvisioningRequest>(() => new ProvisioningRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProvisioningRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningRequest(ProvisioningRequest other) : this() {
      clientId_ = other.clientId_ != null ? other.clientId_.Clone() : null;
      nonce_ = other.nonce_;
      options_ = other.options_ != null ? other.options_.Clone() : null;
      stableId_ = other.stableId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningRequest Clone() {
      return new ProvisioningRequest(this);
    }

    /// <summary>Field number for the "client_id" field.</summary>
    public const int ClientIdFieldNumber = 1;
    private global::AAXClean.Widevine.Provisioning.ClientIdentification clientId_;
    /// <summary>
    /// Device root of trust and other client identification. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ClientIdentification ClientId {
      get { return clientId_; }
      set {
        clientId_ = value;
      }
    }

    /// <summary>Field number for the "nonce" field.</summary>
    public const int NonceFieldNumber = 2;
    private readonly static pb::ByteString NonceDefaultValue = pb::ByteString.Empty;

    private pb::ByteString nonce_;
    /// <summary>
    /// Nonce value used to prevent replay attacks. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Nonce {
      get { return nonce_ ?? NonceDefaultValue; }
      set {
        nonce_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nonce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNonce {
      get { return nonce_ != null; }
    }
    /// <summary>Clears the value of the "nonce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNonce() {
      nonce_ = null;
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 3;
    private global::AAXClean.Widevine.Provisioning.ProvisioningOptions options_;
    /// <summary>
    /// Options for type of certificate to generate.  Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ProvisioningOptions Options {
      get { return options_; }
      set {
        options_ = value;
      }
    }

    /// <summary>Field number for the "stable_id" field.</summary>
    public const int StableIdFieldNumber = 4;
    private readonly static pb::ByteString StableIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString stableId_;
    /// <summary>
    /// Stable identifier, unique for each device + application (or origin).
    /// Required if doing per-origin provisioning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString StableId {
      get { return stableId_ ?? StableIdDefaultValue; }
      set {
        stableId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "stable_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStableId {
      get { return stableId_ != null; }
    }
    /// <summary>Clears the value of the "stable_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStableId() {
      stableId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProvisioningRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProvisioningRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ClientId, other.ClientId)) return false;
      if (Nonce != other.Nonce) return false;
      if (!object.Equals(Options, other.Options)) return false;
      if (StableId != other.StableId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (clientId_ != null) hash ^= ClientId.GetHashCode();
      if (HasNonce) hash ^= Nonce.GetHashCode();
      if (options_ != null) hash ^= Options.GetHashCode();
      if (HasStableId) hash ^= StableId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (clientId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientId);
      }
      if (HasNonce) {
        output.WriteRawTag(18);
        output.WriteBytes(Nonce);
      }
      if (options_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Options);
      }
      if (HasStableId) {
        output.WriteRawTag(34);
        output.WriteBytes(StableId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (clientId_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientId);
      }
      if (HasNonce) {
        output.WriteRawTag(18);
        output.WriteBytes(Nonce);
      }
      if (options_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Options);
      }
      if (HasStableId) {
        output.WriteRawTag(34);
        output.WriteBytes(StableId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (clientId_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientId);
      }
      if (HasNonce) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Nonce);
      }
      if (options_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Options);
      }
      if (HasStableId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(StableId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProvisioningRequest other) {
      if (other == null) {
        return;
      }
      if (other.clientId_ != null) {
        if (clientId_ == null) {
          ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
        }
        ClientId.MergeFrom(other.ClientId);
      }
      if (other.HasNonce) {
        Nonce = other.Nonce;
      }
      if (other.options_ != null) {
        if (options_ == null) {
          Options = new global::AAXClean.Widevine.Provisioning.ProvisioningOptions();
        }
        Options.MergeFrom(other.Options);
      }
      if (other.HasStableId) {
        StableId = other.StableId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (clientId_ == null) {
              ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
            }
            input.ReadMessage(ClientId);
            break;
          }
          case 18: {
            Nonce = input.ReadBytes();
            break;
          }
          case 26: {
            if (options_ == null) {
              Options = new global::AAXClean.Widevine.Provisioning.ProvisioningOptions();
            }
            input.ReadMessage(Options);
            break;
          }
          case 34: {
            StableId = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (clientId_ == null) {
              ClientId = new global::AAXClean.Widevine.Provisioning.ClientIdentification();
            }
            input.ReadMessage(ClientId);
            break;
          }
          case 18: {
            Nonce = input.ReadBytes();
            break;
          }
          case 26: {
            if (options_ == null) {
              Options = new global::AAXClean.Widevine.Provisioning.ProvisioningOptions();
            }
            input.ReadMessage(Options);
            break;
          }
          case 34: {
            StableId = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Provisioning response sent by the provisioning server to client devices.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ProvisioningResponse : pb::IMessage<ProvisioningResponse>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProvisioningResponse> _parser = new pb::MessageParser<ProvisioningResponse>(() => new ProvisioningResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProvisioningResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningResponse(ProvisioningResponse other) : this() {
      deviceRsaKey_ = other.deviceRsaKey_;
      deviceRsaKeyIv_ = other.deviceRsaKeyIv_;
      deviceCertificate_ = other.deviceCertificate_;
      nonce_ = other.nonce_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisioningResponse Clone() {
      return new ProvisioningResponse(this);
    }

    /// <summary>Field number for the "device_rsa_key" field.</summary>
    public const int DeviceRsaKeyFieldNumber = 1;
    private readonly static pb::ByteString DeviceRsaKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString deviceRsaKey_;
    /// <summary>
    /// AES-128 encrypted device private RSA key. PKCS#1 ASN.1 DER-encoded.
    /// Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DeviceRsaKey {
      get { return deviceRsaKey_ ?? DeviceRsaKeyDefaultValue; }
      set {
        deviceRsaKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_rsa_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceRsaKey {
      get { return deviceRsaKey_ != null; }
    }
    /// <summary>Clears the value of the "device_rsa_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceRsaKey() {
      deviceRsaKey_ = null;
    }

    /// <summary>Field number for the "device_rsa_key_iv" field.</summary>
    public const int DeviceRsaKeyIvFieldNumber = 2;
    private readonly static pb::ByteString DeviceRsaKeyIvDefaultValue = pb::ByteString.Empty;

    private pb::ByteString deviceRsaKeyIv_;
    /// <summary>
    /// Initialization vector used to encrypt device_rsa_key. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DeviceRsaKeyIv {
      get { return deviceRsaKeyIv_ ?? DeviceRsaKeyIvDefaultValue; }
      set {
        deviceRsaKeyIv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_rsa_key_iv" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceRsaKeyIv {
      get { return deviceRsaKeyIv_ != null; }
    }
    /// <summary>Clears the value of the "device_rsa_key_iv" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceRsaKeyIv() {
      deviceRsaKeyIv_ = null;
    }

    /// <summary>Field number for the "device_certificate" field.</summary>
    public const int DeviceCertificateFieldNumber = 3;
    private readonly static pb::ByteString DeviceCertificateDefaultValue = pb::ByteString.Empty;

    private pb::ByteString deviceCertificate_;
    /// <summary>
    /// Serialized SignedDeviceCertificate. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DeviceCertificate {
      get { return deviceCertificate_ ?? DeviceCertificateDefaultValue; }
      set {
        deviceCertificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_certificate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceCertificate {
      get { return deviceCertificate_ != null; }
    }
    /// <summary>Clears the value of the "device_certificate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceCertificate() {
      deviceCertificate_ = null;
    }

    /// <summary>Field number for the "nonce" field.</summary>
    public const int NonceFieldNumber = 4;
    private readonly static pb::ByteString NonceDefaultValue = pb::ByteString.Empty;

    private pb::ByteString nonce_;
    /// <summary>
    /// Nonce value matching nonce in ProvisioningRequest. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Nonce {
      get { return nonce_ ?? NonceDefaultValue; }
      set {
        nonce_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nonce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNonce {
      get { return nonce_ != null; }
    }
    /// <summary>Clears the value of the "nonce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNonce() {
      nonce_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProvisioningResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProvisioningResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeviceRsaKey != other.DeviceRsaKey) return false;
      if (DeviceRsaKeyIv != other.DeviceRsaKeyIv) return false;
      if (DeviceCertificate != other.DeviceCertificate) return false;
      if (Nonce != other.Nonce) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDeviceRsaKey) hash ^= DeviceRsaKey.GetHashCode();
      if (HasDeviceRsaKeyIv) hash ^= DeviceRsaKeyIv.GetHashCode();
      if (HasDeviceCertificate) hash ^= DeviceCertificate.GetHashCode();
      if (HasNonce) hash ^= Nonce.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDeviceRsaKey) {
        output.WriteRawTag(10);
        output.WriteBytes(DeviceRsaKey);
      }
      if (HasDeviceRsaKeyIv) {
        output.WriteRawTag(18);
        output.WriteBytes(DeviceRsaKeyIv);
      }
      if (HasDeviceCertificate) {
        output.WriteRawTag(26);
        output.WriteBytes(DeviceCertificate);
      }
      if (HasNonce) {
        output.WriteRawTag(34);
        output.WriteBytes(Nonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDeviceRsaKey) {
        output.WriteRawTag(10);
        output.WriteBytes(DeviceRsaKey);
      }
      if (HasDeviceRsaKeyIv) {
        output.WriteRawTag(18);
        output.WriteBytes(DeviceRsaKeyIv);
      }
      if (HasDeviceCertificate) {
        output.WriteRawTag(26);
        output.WriteBytes(DeviceCertificate);
      }
      if (HasNonce) {
        output.WriteRawTag(34);
        output.WriteBytes(Nonce);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDeviceRsaKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DeviceRsaKey);
      }
      if (HasDeviceRsaKeyIv) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DeviceRsaKeyIv);
      }
      if (HasDeviceCertificate) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DeviceCertificate);
      }
      if (HasNonce) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Nonce);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProvisioningResponse other) {
      if (other == null) {
        return;
      }
      if (other.HasDeviceRsaKey) {
        DeviceRsaKey = other.DeviceRsaKey;
      }
      if (other.HasDeviceRsaKeyIv) {
        DeviceRsaKeyIv = other.DeviceRsaKeyIv;
      }
      if (other.HasDeviceCertificate) {
        DeviceCertificate = other.DeviceCertificate;
      }
      if (other.HasNonce) {
        Nonce = other.Nonce;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DeviceRsaKey = input.ReadBytes();
            break;
          }
          case 18: {
            DeviceRsaKeyIv = input.ReadBytes();
            break;
          }
          case 26: {
            DeviceCertificate = input.ReadBytes();
            break;
          }
          case 34: {
            Nonce = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DeviceRsaKey = input.ReadBytes();
            break;
          }
          case 18: {
            DeviceRsaKeyIv = input.ReadBytes();
            break;
          }
          case 26: {
            DeviceCertificate = input.ReadBytes();
            break;
          }
          case 34: {
            Nonce = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Serialized ProvisioningRequest or ProvisioningResponse signed with
  /// The message authentication key.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignedProvisioningMessage : pb::IMessage<SignedProvisioningMessage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignedProvisioningMessage> _parser = new pb::MessageParser<SignedProvisioningMessage>(() => new SignedProvisioningMessage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignedProvisioningMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedProvisioningMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedProvisioningMessage(SignedProvisioningMessage other) : this() {
      message_ = other.message_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedProvisioningMessage Clone() {
      return new SignedProvisioningMessage(this);
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 1;
    private readonly static pb::ByteString MessageDefaultValue = pb::ByteString.Empty;

    private pb::ByteString message_;
    /// <summary>
    /// Serialized ProvisioningRequest or ProvisioningResponse. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    /// <summary>
    /// HMAC-SHA256 signature of message. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignedProvisioningMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignedProvisioningMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Message != other.Message) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMessage) {
        output.WriteRawTag(10);
        output.WriteBytes(Message);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMessage) {
        output.WriteRawTag(10);
        output.WriteBytes(Message);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Message);
      }
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignedProvisioningMessage other) {
      if (other == null) {
        return;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Message = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Message = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ClientIdentification message used to authenticate the client device.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ClientIdentification : pb::IMessage<ClientIdentification>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClientIdentification> _parser = new pb::MessageParser<ClientIdentification>(() => new ClientIdentification());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClientIdentification> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIdentification() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIdentification(ClientIdentification other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      token_ = other.token_;
      clientInfo_ = other.clientInfo_.Clone();
      providerClientToken_ = other.providerClientToken_;
      licenseCounter_ = other.licenseCounter_;
      clientCapabilities_ = other.clientCapabilities_ != null ? other.clientCapabilities_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIdentification Clone() {
      return new ClientIdentification(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType.Keybox;

    private global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType type_;
    /// <summary>
    /// Type of factory-provisioned device root of trust. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "token" field.</summary>
    public const int TokenFieldNumber = 2;
    private readonly static pb::ByteString TokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString token_;
    /// <summary>
    /// Factory-provisioned device root of trust. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Token {
      get { return token_ ?? TokenDefaultValue; }
      set {
        token_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasToken {
      get { return token_ != null; }
    }
    /// <summary>Clears the value of the "token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearToken() {
      token_ = null;
    }

    /// <summary>Field number for the "client_info" field.</summary>
    public const int ClientInfoFieldNumber = 3;
    private static readonly pb::FieldCodec<global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue> _repeated_clientInfo_codec
        = pb::FieldCodec.ForMessage(26, global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue.Parser);
    private readonly pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue> clientInfo_ = new pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue>();
    /// <summary>
    /// Optional client information name/value pairs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.NameValue> ClientInfo {
      get { return clientInfo_; }
    }

    /// <summary>Field number for the "provider_client_token" field.</summary>
    public const int ProviderClientTokenFieldNumber = 4;
    private readonly static pb::ByteString ProviderClientTokenDefaultValue = pb::ByteString.Empty;

    private pb::ByteString providerClientToken_;
    /// <summary>
    /// Client token generated by the content provider. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ProviderClientToken {
      get { return providerClientToken_ ?? ProviderClientTokenDefaultValue; }
      set {
        providerClientToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "provider_client_token" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProviderClientToken {
      get { return providerClientToken_ != null; }
    }
    /// <summary>Clears the value of the "provider_client_token" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProviderClientToken() {
      providerClientToken_ = null;
    }

    /// <summary>Field number for the "license_counter" field.</summary>
    public const int LicenseCounterFieldNumber = 5;
    private readonly static uint LicenseCounterDefaultValue = 0;

    private uint licenseCounter_;
    /// <summary>
    /// Number of licenses received by the client to which the token above belongs.
    /// Only present if client_token is specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint LicenseCounter {
      get { if ((_hasBits0 & 2) != 0) { return licenseCounter_; } else { return LicenseCounterDefaultValue; } }
      set {
        _hasBits0 |= 2;
        licenseCounter_ = value;
      }
    }
    /// <summary>Gets whether the "license_counter" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLicenseCounter {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "license_counter" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLicenseCounter() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "client_capabilities" field.</summary>
    public const int ClientCapabilitiesFieldNumber = 6;
    private global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities clientCapabilities_;
    /// <summary>
    /// List of non-baseline client capabilities.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities ClientCapabilities {
      get { return clientCapabilities_; }
      set {
        clientCapabilities_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClientIdentification);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClientIdentification other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Token != other.Token) return false;
      if(!clientInfo_.Equals(other.clientInfo_)) return false;
      if (ProviderClientToken != other.ProviderClientToken) return false;
      if (LicenseCounter != other.LicenseCounter) return false;
      if (!object.Equals(ClientCapabilities, other.ClientCapabilities)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasToken) hash ^= Token.GetHashCode();
      hash ^= clientInfo_.GetHashCode();
      if (HasProviderClientToken) hash ^= ProviderClientToken.GetHashCode();
      if (HasLicenseCounter) hash ^= LicenseCounter.GetHashCode();
      if (clientCapabilities_ != null) hash ^= ClientCapabilities.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasToken) {
        output.WriteRawTag(18);
        output.WriteBytes(Token);
      }
      clientInfo_.WriteTo(output, _repeated_clientInfo_codec);
      if (HasProviderClientToken) {
        output.WriteRawTag(34);
        output.WriteBytes(ProviderClientToken);
      }
      if (HasLicenseCounter) {
        output.WriteRawTag(40);
        output.WriteUInt32(LicenseCounter);
      }
      if (clientCapabilities_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ClientCapabilities);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasToken) {
        output.WriteRawTag(18);
        output.WriteBytes(Token);
      }
      clientInfo_.WriteTo(ref output, _repeated_clientInfo_codec);
      if (HasProviderClientToken) {
        output.WriteRawTag(34);
        output.WriteBytes(ProviderClientToken);
      }
      if (HasLicenseCounter) {
        output.WriteRawTag(40);
        output.WriteUInt32(LicenseCounter);
      }
      if (clientCapabilities_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ClientCapabilities);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Token);
      }
      size += clientInfo_.CalculateSize(_repeated_clientInfo_codec);
      if (HasProviderClientToken) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ProviderClientToken);
      }
      if (HasLicenseCounter) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LicenseCounter);
      }
      if (clientCapabilities_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientCapabilities);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClientIdentification other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasToken) {
        Token = other.Token;
      }
      clientInfo_.Add(other.clientInfo_);
      if (other.HasProviderClientToken) {
        ProviderClientToken = other.ProviderClientToken;
      }
      if (other.HasLicenseCounter) {
        LicenseCounter = other.LicenseCounter;
      }
      if (other.clientCapabilities_ != null) {
        if (clientCapabilities_ == null) {
          ClientCapabilities = new global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities();
        }
        ClientCapabilities.MergeFrom(other.ClientCapabilities);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType) input.ReadEnum();
            break;
          }
          case 18: {
            Token = input.ReadBytes();
            break;
          }
          case 26: {
            clientInfo_.AddEntriesFrom(input, _repeated_clientInfo_codec);
            break;
          }
          case 34: {
            ProviderClientToken = input.ReadBytes();
            break;
          }
          case 40: {
            LicenseCounter = input.ReadUInt32();
            break;
          }
          case 50: {
            if (clientCapabilities_ == null) {
              ClientCapabilities = new global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities();
            }
            input.ReadMessage(ClientCapabilities);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.TokenType) input.ReadEnum();
            break;
          }
          case 18: {
            Token = input.ReadBytes();
            break;
          }
          case 26: {
            clientInfo_.AddEntriesFrom(ref input, _repeated_clientInfo_codec);
            break;
          }
          case 34: {
            ProviderClientToken = input.ReadBytes();
            break;
          }
          case 40: {
            LicenseCounter = input.ReadUInt32();
            break;
          }
          case 50: {
            if (clientCapabilities_ == null) {
              ClientCapabilities = new global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities();
            }
            input.ReadMessage(ClientCapabilities);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ClientIdentification message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum TokenType {
        [pbr::OriginalName("KEYBOX")] Keybox = 0,
        [pbr::OriginalName("DEVICE_CERTIFICATE")] DeviceCertificate = 1,
        [pbr::OriginalName("REMOTE_ATTESTATION_CERTIFICATE")] RemoteAttestationCertificate = 2,
      }

      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class NameValue : pb::IMessage<NameValue>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<NameValue> _parser = new pb::MessageParser<NameValue>(() => new NameValue());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<NameValue> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AAXClean.Widevine.Provisioning.ClientIdentification.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NameValue() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NameValue(NameValue other) : this() {
          name_ = other.name_;
          value_ = other.value_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public NameValue Clone() {
          return new NameValue(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private readonly static string NameDefaultValue = "";

        private string name_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_ ?? NameDefaultValue; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "name" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasName {
          get { return name_ != null; }
        }
        /// <summary>Clears the value of the "name" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearName() {
          name_ = null;
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private readonly static string ValueDefaultValue = "";

        private string value_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Value {
          get { return value_ ?? ValueDefaultValue; }
          set {
            value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }
        /// <summary>Gets whether the "value" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasValue {
          get { return value_ != null; }
        }
        /// <summary>Clears the value of the "value" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearValue() {
          value_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as NameValue);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(NameValue other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Value != other.Value) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasName) hash ^= Name.GetHashCode();
          if (HasValue) hash ^= Value.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasName) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasValue) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasName) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (HasValue) {
            output.WriteRawTag(18);
            output.WriteString(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasName) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (HasValue) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(NameValue other) {
          if (other == null) {
            return;
          }
          if (other.HasName) {
            Name = other.Name;
          }
          if (other.HasValue) {
            Value = other.Value;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                Value = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// Capabilities which not all clients may support. Used for the license
      /// exchange protocol only.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ClientCapabilities : pb::IMessage<ClientCapabilities>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ClientCapabilities> _parser = new pb::MessageParser<ClientCapabilities>(() => new ClientCapabilities());
        private pb::UnknownFieldSet _unknownFields;
        private int _hasBits0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ClientCapabilities> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::AAXClean.Widevine.Provisioning.ClientIdentification.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClientCapabilities() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClientCapabilities(ClientCapabilities other) : this() {
          _hasBits0 = other._hasBits0;
          clientToken_ = other.clientToken_;
          sessionToken_ = other.sessionToken_;
          videoResolutionConstraints_ = other.videoResolutionConstraints_;
          maxHdcpVersion_ = other.maxHdcpVersion_;
          oemCryptoApiVersion_ = other.oemCryptoApiVersion_;
          antiRollbackUsageTable_ = other.antiRollbackUsageTable_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ClientCapabilities Clone() {
          return new ClientCapabilities(this);
        }

        /// <summary>Field number for the "client_token" field.</summary>
        public const int ClientTokenFieldNumber = 1;
        private readonly static bool ClientTokenDefaultValue = false;

        private bool clientToken_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ClientToken {
          get { if ((_hasBits0 & 1) != 0) { return clientToken_; } else { return ClientTokenDefaultValue; } }
          set {
            _hasBits0 |= 1;
            clientToken_ = value;
          }
        }
        /// <summary>Gets whether the "client_token" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasClientToken {
          get { return (_hasBits0 & 1) != 0; }
        }
        /// <summary>Clears the value of the "client_token" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearClientToken() {
          _hasBits0 &= ~1;
        }

        /// <summary>Field number for the "session_token" field.</summary>
        public const int SessionTokenFieldNumber = 2;
        private readonly static bool SessionTokenDefaultValue = false;

        private bool sessionToken_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool SessionToken {
          get { if ((_hasBits0 & 2) != 0) { return sessionToken_; } else { return SessionTokenDefaultValue; } }
          set {
            _hasBits0 |= 2;
            sessionToken_ = value;
          }
        }
        /// <summary>Gets whether the "session_token" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasSessionToken {
          get { return (_hasBits0 & 2) != 0; }
        }
        /// <summary>Clears the value of the "session_token" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearSessionToken() {
          _hasBits0 &= ~2;
        }

        /// <summary>Field number for the "video_resolution_constraints" field.</summary>
        public const int VideoResolutionConstraintsFieldNumber = 3;
        private readonly static bool VideoResolutionConstraintsDefaultValue = false;

        private bool videoResolutionConstraints_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool VideoResolutionConstraints {
          get { if ((_hasBits0 & 4) != 0) { return videoResolutionConstraints_; } else { return VideoResolutionConstraintsDefaultValue; } }
          set {
            _hasBits0 |= 4;
            videoResolutionConstraints_ = value;
          }
        }
        /// <summary>Gets whether the "video_resolution_constraints" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasVideoResolutionConstraints {
          get { return (_hasBits0 & 4) != 0; }
        }
        /// <summary>Clears the value of the "video_resolution_constraints" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearVideoResolutionConstraints() {
          _hasBits0 &= ~4;
        }

        /// <summary>Field number for the "max_hdcp_version" field.</summary>
        public const int MaxHdcpVersionFieldNumber = 4;
        private readonly static global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion MaxHdcpVersionDefaultValue = global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion.HdcpNone;

        private global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion maxHdcpVersion_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion MaxHdcpVersion {
          get { if ((_hasBits0 & 8) != 0) { return maxHdcpVersion_; } else { return MaxHdcpVersionDefaultValue; } }
          set {
            _hasBits0 |= 8;
            maxHdcpVersion_ = value;
          }
        }
        /// <summary>Gets whether the "max_hdcp_version" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasMaxHdcpVersion {
          get { return (_hasBits0 & 8) != 0; }
        }
        /// <summary>Clears the value of the "max_hdcp_version" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearMaxHdcpVersion() {
          _hasBits0 &= ~8;
        }

        /// <summary>Field number for the "oem_crypto_api_version" field.</summary>
        public const int OemCryptoApiVersionFieldNumber = 5;
        private readonly static uint OemCryptoApiVersionDefaultValue = 0;

        private uint oemCryptoApiVersion_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint OemCryptoApiVersion {
          get { if ((_hasBits0 & 16) != 0) { return oemCryptoApiVersion_; } else { return OemCryptoApiVersionDefaultValue; } }
          set {
            _hasBits0 |= 16;
            oemCryptoApiVersion_ = value;
          }
        }
        /// <summary>Gets whether the "oem_crypto_api_version" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasOemCryptoApiVersion {
          get { return (_hasBits0 & 16) != 0; }
        }
        /// <summary>Clears the value of the "oem_crypto_api_version" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearOemCryptoApiVersion() {
          _hasBits0 &= ~16;
        }

        /// <summary>Field number for the "anti_rollback_usage_table" field.</summary>
        public const int AntiRollbackUsageTableFieldNumber = 6;
        private readonly static bool AntiRollbackUsageTableDefaultValue = false;

        private bool antiRollbackUsageTable_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool AntiRollbackUsageTable {
          get { if ((_hasBits0 & 32) != 0) { return antiRollbackUsageTable_; } else { return AntiRollbackUsageTableDefaultValue; } }
          set {
            _hasBits0 |= 32;
            antiRollbackUsageTable_ = value;
          }
        }
        /// <summary>Gets whether the "anti_rollback_usage_table" field is set</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool HasAntiRollbackUsageTable {
          get { return (_hasBits0 & 32) != 0; }
        }
        /// <summary>Clears the value of the "anti_rollback_usage_table" field</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearAntiRollbackUsageTable() {
          _hasBits0 &= ~32;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ClientCapabilities);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ClientCapabilities other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ClientToken != other.ClientToken) return false;
          if (SessionToken != other.SessionToken) return false;
          if (VideoResolutionConstraints != other.VideoResolutionConstraints) return false;
          if (MaxHdcpVersion != other.MaxHdcpVersion) return false;
          if (OemCryptoApiVersion != other.OemCryptoApiVersion) return false;
          if (AntiRollbackUsageTable != other.AntiRollbackUsageTable) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (HasClientToken) hash ^= ClientToken.GetHashCode();
          if (HasSessionToken) hash ^= SessionToken.GetHashCode();
          if (HasVideoResolutionConstraints) hash ^= VideoResolutionConstraints.GetHashCode();
          if (HasMaxHdcpVersion) hash ^= MaxHdcpVersion.GetHashCode();
          if (HasOemCryptoApiVersion) hash ^= OemCryptoApiVersion.GetHashCode();
          if (HasAntiRollbackUsageTable) hash ^= AntiRollbackUsageTable.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (HasClientToken) {
            output.WriteRawTag(8);
            output.WriteBool(ClientToken);
          }
          if (HasSessionToken) {
            output.WriteRawTag(16);
            output.WriteBool(SessionToken);
          }
          if (HasVideoResolutionConstraints) {
            output.WriteRawTag(24);
            output.WriteBool(VideoResolutionConstraints);
          }
          if (HasMaxHdcpVersion) {
            output.WriteRawTag(32);
            output.WriteEnum((int) MaxHdcpVersion);
          }
          if (HasOemCryptoApiVersion) {
            output.WriteRawTag(40);
            output.WriteUInt32(OemCryptoApiVersion);
          }
          if (HasAntiRollbackUsageTable) {
            output.WriteRawTag(48);
            output.WriteBool(AntiRollbackUsageTable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (HasClientToken) {
            output.WriteRawTag(8);
            output.WriteBool(ClientToken);
          }
          if (HasSessionToken) {
            output.WriteRawTag(16);
            output.WriteBool(SessionToken);
          }
          if (HasVideoResolutionConstraints) {
            output.WriteRawTag(24);
            output.WriteBool(VideoResolutionConstraints);
          }
          if (HasMaxHdcpVersion) {
            output.WriteRawTag(32);
            output.WriteEnum((int) MaxHdcpVersion);
          }
          if (HasOemCryptoApiVersion) {
            output.WriteRawTag(40);
            output.WriteUInt32(OemCryptoApiVersion);
          }
          if (HasAntiRollbackUsageTable) {
            output.WriteRawTag(48);
            output.WriteBool(AntiRollbackUsageTable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (HasClientToken) {
            size += 1 + 1;
          }
          if (HasSessionToken) {
            size += 1 + 1;
          }
          if (HasVideoResolutionConstraints) {
            size += 1 + 1;
          }
          if (HasMaxHdcpVersion) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MaxHdcpVersion);
          }
          if (HasOemCryptoApiVersion) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(OemCryptoApiVersion);
          }
          if (HasAntiRollbackUsageTable) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ClientCapabilities other) {
          if (other == null) {
            return;
          }
          if (other.HasClientToken) {
            ClientToken = other.ClientToken;
          }
          if (other.HasSessionToken) {
            SessionToken = other.SessionToken;
          }
          if (other.HasVideoResolutionConstraints) {
            VideoResolutionConstraints = other.VideoResolutionConstraints;
          }
          if (other.HasMaxHdcpVersion) {
            MaxHdcpVersion = other.MaxHdcpVersion;
          }
          if (other.HasOemCryptoApiVersion) {
            OemCryptoApiVersion = other.OemCryptoApiVersion;
          }
          if (other.HasAntiRollbackUsageTable) {
            AntiRollbackUsageTable = other.AntiRollbackUsageTable;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                ClientToken = input.ReadBool();
                break;
              }
              case 16: {
                SessionToken = input.ReadBool();
                break;
              }
              case 24: {
                VideoResolutionConstraints = input.ReadBool();
                break;
              }
              case 32: {
                MaxHdcpVersion = (global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion) input.ReadEnum();
                break;
              }
              case 40: {
                OemCryptoApiVersion = input.ReadUInt32();
                break;
              }
              case 48: {
                AntiRollbackUsageTable = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                ClientToken = input.ReadBool();
                break;
              }
              case 16: {
                SessionToken = input.ReadBool();
                break;
              }
              case 24: {
                VideoResolutionConstraints = input.ReadBool();
                break;
              }
              case 32: {
                MaxHdcpVersion = (global::AAXClean.Widevine.Provisioning.ClientIdentification.Types.ClientCapabilities.Types.HdcpVersion) input.ReadEnum();
                break;
              }
              case 40: {
                OemCryptoApiVersion = input.ReadUInt32();
                break;
              }
              case 48: {
                AntiRollbackUsageTable = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ClientCapabilities message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          public enum HdcpVersion {
            [pbr::OriginalName("HDCP_NONE")] HdcpNone = 0,
            [pbr::OriginalName("HDCP_V1")] HdcpV1 = 1,
            [pbr::OriginalName("HDCP_V2")] HdcpV2 = 2,
            [pbr::OriginalName("HDCP_V2_1")] HdcpV21 = 3,
            [pbr::OriginalName("HDCP_V2_2")] HdcpV22 = 4,
            [pbr::OriginalName("HDCP_NO_DIGITAL_OUTPUT")] HdcpNoDigitalOutput = 255,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// EncryptedClientIdentification message used to hold ClientIdentification
  /// messages encrypted for privacy purposes.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class EncryptedClientIdentification : pb::IMessage<EncryptedClientIdentification>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EncryptedClientIdentification> _parser = new pb::MessageParser<EncryptedClientIdentification>(() => new EncryptedClientIdentification());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EncryptedClientIdentification> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptedClientIdentification() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptedClientIdentification(EncryptedClientIdentification other) : this() {
      serviceId_ = other.serviceId_;
      serviceCertificateSerialNumber_ = other.serviceCertificateSerialNumber_;
      encryptedClientId_ = other.encryptedClientId_;
      encryptedClientIdIv_ = other.encryptedClientIdIv_;
      encryptedPrivacyKey_ = other.encryptedPrivacyKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EncryptedClientIdentification Clone() {
      return new EncryptedClientIdentification(this);
    }

    /// <summary>Field number for the "service_id" field.</summary>
    public const int ServiceIdFieldNumber = 1;
    private readonly static string ServiceIdDefaultValue = "";

    private string serviceId_;
    /// <summary>
    /// Service ID for which the ClientIdentifcation is encrypted (owner of service
    /// certificate).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServiceId {
      get { return serviceId_ ?? ServiceIdDefaultValue; }
      set {
        serviceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "service_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServiceId {
      get { return serviceId_ != null; }
    }
    /// <summary>Clears the value of the "service_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServiceId() {
      serviceId_ = null;
    }

    /// <summary>Field number for the "service_certificate_serial_number" field.</summary>
    public const int ServiceCertificateSerialNumberFieldNumber = 2;
    private readonly static pb::ByteString ServiceCertificateSerialNumberDefaultValue = pb::ByteString.Empty;

    private pb::ByteString serviceCertificateSerialNumber_;
    /// <summary>
    /// Serial number for the service certificate for which ClientIdentification is
    /// encrypted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString ServiceCertificateSerialNumber {
      get { return serviceCertificateSerialNumber_ ?? ServiceCertificateSerialNumberDefaultValue; }
      set {
        serviceCertificateSerialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "service_certificate_serial_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServiceCertificateSerialNumber {
      get { return serviceCertificateSerialNumber_ != null; }
    }
    /// <summary>Clears the value of the "service_certificate_serial_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServiceCertificateSerialNumber() {
      serviceCertificateSerialNumber_ = null;
    }

    /// <summary>Field number for the "encrypted_client_id" field.</summary>
    public const int EncryptedClientIdFieldNumber = 3;
    private readonly static pb::ByteString EncryptedClientIdDefaultValue = pb::ByteString.Empty;

    private pb::ByteString encryptedClientId_;
    /// <summary>
    /// Serialized ClientIdentification message, encrypted with the privacy key using
    /// AES-128-CBC with PKCS#5 padding.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EncryptedClientId {
      get { return encryptedClientId_ ?? EncryptedClientIdDefaultValue; }
      set {
        encryptedClientId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "encrypted_client_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEncryptedClientId {
      get { return encryptedClientId_ != null; }
    }
    /// <summary>Clears the value of the "encrypted_client_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEncryptedClientId() {
      encryptedClientId_ = null;
    }

    /// <summary>Field number for the "encrypted_client_id_iv" field.</summary>
    public const int EncryptedClientIdIvFieldNumber = 4;
    private readonly static pb::ByteString EncryptedClientIdIvDefaultValue = pb::ByteString.Empty;

    private pb::ByteString encryptedClientIdIv_;
    /// <summary>
    /// Initialization vector needed to decrypt encrypted_client_id.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EncryptedClientIdIv {
      get { return encryptedClientIdIv_ ?? EncryptedClientIdIvDefaultValue; }
      set {
        encryptedClientIdIv_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "encrypted_client_id_iv" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEncryptedClientIdIv {
      get { return encryptedClientIdIv_ != null; }
    }
    /// <summary>Clears the value of the "encrypted_client_id_iv" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEncryptedClientIdIv() {
      encryptedClientIdIv_ = null;
    }

    /// <summary>Field number for the "encrypted_privacy_key" field.</summary>
    public const int EncryptedPrivacyKeyFieldNumber = 5;
    private readonly static pb::ByteString EncryptedPrivacyKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString encryptedPrivacyKey_;
    /// <summary>
    /// AES-128 privacy key, encrytped with the service public public key using
    /// RSA-OAEP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString EncryptedPrivacyKey {
      get { return encryptedPrivacyKey_ ?? EncryptedPrivacyKeyDefaultValue; }
      set {
        encryptedPrivacyKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "encrypted_privacy_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEncryptedPrivacyKey {
      get { return encryptedPrivacyKey_ != null; }
    }
    /// <summary>Clears the value of the "encrypted_privacy_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEncryptedPrivacyKey() {
      encryptedPrivacyKey_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EncryptedClientIdentification);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EncryptedClientIdentification other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ServiceId != other.ServiceId) return false;
      if (ServiceCertificateSerialNumber != other.ServiceCertificateSerialNumber) return false;
      if (EncryptedClientId != other.EncryptedClientId) return false;
      if (EncryptedClientIdIv != other.EncryptedClientIdIv) return false;
      if (EncryptedPrivacyKey != other.EncryptedPrivacyKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasServiceId) hash ^= ServiceId.GetHashCode();
      if (HasServiceCertificateSerialNumber) hash ^= ServiceCertificateSerialNumber.GetHashCode();
      if (HasEncryptedClientId) hash ^= EncryptedClientId.GetHashCode();
      if (HasEncryptedClientIdIv) hash ^= EncryptedClientIdIv.GetHashCode();
      if (HasEncryptedPrivacyKey) hash ^= EncryptedPrivacyKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasServiceId) {
        output.WriteRawTag(10);
        output.WriteString(ServiceId);
      }
      if (HasServiceCertificateSerialNumber) {
        output.WriteRawTag(18);
        output.WriteBytes(ServiceCertificateSerialNumber);
      }
      if (HasEncryptedClientId) {
        output.WriteRawTag(26);
        output.WriteBytes(EncryptedClientId);
      }
      if (HasEncryptedClientIdIv) {
        output.WriteRawTag(34);
        output.WriteBytes(EncryptedClientIdIv);
      }
      if (HasEncryptedPrivacyKey) {
        output.WriteRawTag(42);
        output.WriteBytes(EncryptedPrivacyKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasServiceId) {
        output.WriteRawTag(10);
        output.WriteString(ServiceId);
      }
      if (HasServiceCertificateSerialNumber) {
        output.WriteRawTag(18);
        output.WriteBytes(ServiceCertificateSerialNumber);
      }
      if (HasEncryptedClientId) {
        output.WriteRawTag(26);
        output.WriteBytes(EncryptedClientId);
      }
      if (HasEncryptedClientIdIv) {
        output.WriteRawTag(34);
        output.WriteBytes(EncryptedClientIdIv);
      }
      if (HasEncryptedPrivacyKey) {
        output.WriteRawTag(42);
        output.WriteBytes(EncryptedPrivacyKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasServiceId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceId);
      }
      if (HasServiceCertificateSerialNumber) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ServiceCertificateSerialNumber);
      }
      if (HasEncryptedClientId) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedClientId);
      }
      if (HasEncryptedClientIdIv) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedClientIdIv);
      }
      if (HasEncryptedPrivacyKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(EncryptedPrivacyKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EncryptedClientIdentification other) {
      if (other == null) {
        return;
      }
      if (other.HasServiceId) {
        ServiceId = other.ServiceId;
      }
      if (other.HasServiceCertificateSerialNumber) {
        ServiceCertificateSerialNumber = other.ServiceCertificateSerialNumber;
      }
      if (other.HasEncryptedClientId) {
        EncryptedClientId = other.EncryptedClientId;
      }
      if (other.HasEncryptedClientIdIv) {
        EncryptedClientIdIv = other.EncryptedClientIdIv;
      }
      if (other.HasEncryptedPrivacyKey) {
        EncryptedPrivacyKey = other.EncryptedPrivacyKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ServiceId = input.ReadString();
            break;
          }
          case 18: {
            ServiceCertificateSerialNumber = input.ReadBytes();
            break;
          }
          case 26: {
            EncryptedClientId = input.ReadBytes();
            break;
          }
          case 34: {
            EncryptedClientIdIv = input.ReadBytes();
            break;
          }
          case 42: {
            EncryptedPrivacyKey = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ServiceId = input.ReadString();
            break;
          }
          case 18: {
            ServiceCertificateSerialNumber = input.ReadBytes();
            break;
          }
          case 26: {
            EncryptedClientId = input.ReadBytes();
            break;
          }
          case 34: {
            EncryptedClientIdIv = input.ReadBytes();
            break;
          }
          case 42: {
            EncryptedPrivacyKey = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Certificate definition for user devices, intermediate, service, and root
  /// certificates.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DeviceCertificate : pb::IMessage<DeviceCertificate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeviceCertificate> _parser = new pb::MessageParser<DeviceCertificate>(() => new DeviceCertificate());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DeviceCertificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificate(DeviceCertificate other) : this() {
      _hasBits0 = other._hasBits0;
      type_ = other.type_;
      serialNumber_ = other.serialNumber_;
      creationTimeSeconds_ = other.creationTimeSeconds_;
      publicKey_ = other.publicKey_;
      systemId_ = other.systemId_;
      testDeviceDeprecated_ = other.testDeviceDeprecated_;
      serviceId_ = other.serviceId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificate Clone() {
      return new DeviceCertificate(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType TypeDefaultValue = global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType.Root;

    private global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType type_;
    /// <summary>
    /// Type of certificate. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType Type {
      get { if ((_hasBits0 & 1) != 0) { return type_; } else { return TypeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        type_ = value;
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "serial_number" field.</summary>
    public const int SerialNumberFieldNumber = 2;
    private readonly static pb::ByteString SerialNumberDefaultValue = pb::ByteString.Empty;

    private pb::ByteString serialNumber_;
    /// <summary>
    /// 128-bit globally unique serial number of certificate.
    /// Value is 0 for root certificate. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SerialNumber {
      get { return serialNumber_ ?? SerialNumberDefaultValue; }
      set {
        serialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "serial_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSerialNumber {
      get { return serialNumber_ != null; }
    }
    /// <summary>Clears the value of the "serial_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSerialNumber() {
      serialNumber_ = null;
    }

    /// <summary>Field number for the "creation_time_seconds" field.</summary>
    public const int CreationTimeSecondsFieldNumber = 3;
    private readonly static uint CreationTimeSecondsDefaultValue = 0;

    private uint creationTimeSeconds_;
    /// <summary>
    /// POSIX time, in seconds, when the certificate was created. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint CreationTimeSeconds {
      get { if ((_hasBits0 & 2) != 0) { return creationTimeSeconds_; } else { return CreationTimeSecondsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        creationTimeSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "creation_time_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCreationTimeSeconds {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "creation_time_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCreationTimeSeconds() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "public_key" field.</summary>
    public const int PublicKeyFieldNumber = 4;
    private readonly static pb::ByteString PublicKeyDefaultValue = pb::ByteString.Empty;

    private pb::ByteString publicKey_;
    /// <summary>
    /// Device public key. PKCS#1 ASN.1 DER-encoded. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString PublicKey {
      get { return publicKey_ ?? PublicKeyDefaultValue; }
      set {
        publicKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "public_key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPublicKey {
      get { return publicKey_ != null; }
    }
    /// <summary>Clears the value of the "public_key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPublicKey() {
      publicKey_ = null;
    }

    /// <summary>Field number for the "system_id" field.</summary>
    public const int SystemIdFieldNumber = 5;
    private readonly static uint SystemIdDefaultValue = 0;

    private uint systemId_;
    /// <summary>
    /// Widevine system ID for the device. Required for intermediate and
    /// user device certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SystemId {
      get { if ((_hasBits0 & 4) != 0) { return systemId_; } else { return SystemIdDefaultValue; } }
      set {
        _hasBits0 |= 4;
        systemId_ = value;
      }
    }
    /// <summary>Gets whether the "system_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSystemId {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "system_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSystemId() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "test_device_deprecated" field.</summary>
    public const int TestDeviceDeprecatedFieldNumber = 6;
    private readonly static bool TestDeviceDeprecatedDefaultValue = false;

    private bool testDeviceDeprecated_;
    /// <summary>
    /// Deprecated field, which used to indicate whether the device was a test
    /// (non-production) device. The test_device field in ProvisionedDeviceInfo
    /// below should be observed instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TestDeviceDeprecated {
      get { if ((_hasBits0 & 8) != 0) { return testDeviceDeprecated_; } else { return TestDeviceDeprecatedDefaultValue; } }
      set {
        _hasBits0 |= 8;
        testDeviceDeprecated_ = value;
      }
    }
    /// <summary>Gets whether the "test_device_deprecated" field is set</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTestDeviceDeprecated {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "test_device_deprecated" field</summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTestDeviceDeprecated() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "service_id" field.</summary>
    public const int ServiceIdFieldNumber = 7;
    private readonly static string ServiceIdDefaultValue = "";

    private string serviceId_;
    /// <summary>
    /// Service identifier (web origin) for the service which owns the certificate.
    /// Required for service certificates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServiceId {
      get { return serviceId_ ?? ServiceIdDefaultValue; }
      set {
        serviceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "service_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServiceId {
      get { return serviceId_ != null; }
    }
    /// <summary>Clears the value of the "service_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServiceId() {
      serviceId_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DeviceCertificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DeviceCertificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (SerialNumber != other.SerialNumber) return false;
      if (CreationTimeSeconds != other.CreationTimeSeconds) return false;
      if (PublicKey != other.PublicKey) return false;
      if (SystemId != other.SystemId) return false;
      if (TestDeviceDeprecated != other.TestDeviceDeprecated) return false;
      if (ServiceId != other.ServiceId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasSerialNumber) hash ^= SerialNumber.GetHashCode();
      if (HasCreationTimeSeconds) hash ^= CreationTimeSeconds.GetHashCode();
      if (HasPublicKey) hash ^= PublicKey.GetHashCode();
      if (HasSystemId) hash ^= SystemId.GetHashCode();
      if (HasTestDeviceDeprecated) hash ^= TestDeviceDeprecated.GetHashCode();
      if (HasServiceId) hash ^= ServiceId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasSerialNumber) {
        output.WriteRawTag(18);
        output.WriteBytes(SerialNumber);
      }
      if (HasCreationTimeSeconds) {
        output.WriteRawTag(24);
        output.WriteUInt32(CreationTimeSeconds);
      }
      if (HasPublicKey) {
        output.WriteRawTag(34);
        output.WriteBytes(PublicKey);
      }
      if (HasSystemId) {
        output.WriteRawTag(40);
        output.WriteUInt32(SystemId);
      }
      if (HasTestDeviceDeprecated) {
        output.WriteRawTag(48);
        output.WriteBool(TestDeviceDeprecated);
      }
      if (HasServiceId) {
        output.WriteRawTag(58);
        output.WriteString(ServiceId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (HasSerialNumber) {
        output.WriteRawTag(18);
        output.WriteBytes(SerialNumber);
      }
      if (HasCreationTimeSeconds) {
        output.WriteRawTag(24);
        output.WriteUInt32(CreationTimeSeconds);
      }
      if (HasPublicKey) {
        output.WriteRawTag(34);
        output.WriteBytes(PublicKey);
      }
      if (HasSystemId) {
        output.WriteRawTag(40);
        output.WriteUInt32(SystemId);
      }
      if (HasTestDeviceDeprecated) {
        output.WriteRawTag(48);
        output.WriteBool(TestDeviceDeprecated);
      }
      if (HasServiceId) {
        output.WriteRawTag(58);
        output.WriteString(ServiceId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (HasSerialNumber) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SerialNumber);
      }
      if (HasCreationTimeSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CreationTimeSeconds);
      }
      if (HasPublicKey) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PublicKey);
      }
      if (HasSystemId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SystemId);
      }
      if (HasTestDeviceDeprecated) {
        size += 1 + 1;
      }
      if (HasServiceId) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DeviceCertificate other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasSerialNumber) {
        SerialNumber = other.SerialNumber;
      }
      if (other.HasCreationTimeSeconds) {
        CreationTimeSeconds = other.CreationTimeSeconds;
      }
      if (other.HasPublicKey) {
        PublicKey = other.PublicKey;
      }
      if (other.HasSystemId) {
        SystemId = other.SystemId;
      }
      if (other.HasTestDeviceDeprecated) {
        TestDeviceDeprecated = other.TestDeviceDeprecated;
      }
      if (other.HasServiceId) {
        ServiceId = other.ServiceId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType) input.ReadEnum();
            break;
          }
          case 18: {
            SerialNumber = input.ReadBytes();
            break;
          }
          case 24: {
            CreationTimeSeconds = input.ReadUInt32();
            break;
          }
          case 34: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 40: {
            SystemId = input.ReadUInt32();
            break;
          }
          case 48: {
            TestDeviceDeprecated = input.ReadBool();
            break;
          }
          case 58: {
            ServiceId = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Type = (global::AAXClean.Widevine.Provisioning.DeviceCertificate.Types.CertificateType) input.ReadEnum();
            break;
          }
          case 18: {
            SerialNumber = input.ReadBytes();
            break;
          }
          case 24: {
            CreationTimeSeconds = input.ReadUInt32();
            break;
          }
          case 34: {
            PublicKey = input.ReadBytes();
            break;
          }
          case 40: {
            SystemId = input.ReadUInt32();
            break;
          }
          case 48: {
            TestDeviceDeprecated = input.ReadBool();
            break;
          }
          case 58: {
            ServiceId = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the DeviceCertificate message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum CertificateType {
        [pbr::OriginalName("ROOT")] Root = 0,
        [pbr::OriginalName("INTERMEDIATE")] Intermediate = 1,
        [pbr::OriginalName("USER_DEVICE")] UserDevice = 2,
        [pbr::OriginalName("SERVICE")] Service = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// DeviceCertificate signed with intermediate or root certificate private key.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignedDeviceCertificate : pb::IMessage<SignedDeviceCertificate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignedDeviceCertificate> _parser = new pb::MessageParser<SignedDeviceCertificate>(() => new SignedDeviceCertificate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignedDeviceCertificate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedDeviceCertificate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedDeviceCertificate(SignedDeviceCertificate other) : this() {
      deviceCertificate_ = other.deviceCertificate_;
      signature_ = other.signature_;
      signer_ = other.signer_ != null ? other.signer_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedDeviceCertificate Clone() {
      return new SignedDeviceCertificate(this);
    }

    /// <summary>Field number for the "device_certificate" field.</summary>
    public const int DeviceCertificateFieldNumber = 1;
    private readonly static pb::ByteString DeviceCertificateDefaultValue = pb::ByteString.Empty;

    private pb::ByteString deviceCertificate_;
    /// <summary>
    /// Serialized DeviceCertificate. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString DeviceCertificate {
      get { return deviceCertificate_ ?? DeviceCertificateDefaultValue; }
      set {
        deviceCertificate_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_certificate" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceCertificate {
      get { return deviceCertificate_ != null; }
    }
    /// <summary>Clears the value of the "device_certificate" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceCertificate() {
      deviceCertificate_ = null;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    /// <summary>
    /// Signature of device_certificate. Signed with root or intermediate
    /// certificate private key using RSASSA-PSS. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signature_ = null;
    }

    /// <summary>Field number for the "signer" field.</summary>
    public const int SignerFieldNumber = 3;
    private global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate signer_;
    /// <summary>
    /// Intermediate signing certificate. Present only for user device
    /// certificates. All others signed with root certificate private key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate Signer {
      get { return signer_; }
      set {
        signer_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignedDeviceCertificate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignedDeviceCertificate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeviceCertificate != other.DeviceCertificate) return false;
      if (Signature != other.Signature) return false;
      if (!object.Equals(Signer, other.Signer)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDeviceCertificate) hash ^= DeviceCertificate.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (signer_ != null) hash ^= Signer.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDeviceCertificate) {
        output.WriteRawTag(10);
        output.WriteBytes(DeviceCertificate);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (signer_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Signer);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDeviceCertificate) {
        output.WriteRawTag(10);
        output.WriteBytes(DeviceCertificate);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (signer_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Signer);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDeviceCertificate) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(DeviceCertificate);
      }
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (signer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Signer);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignedDeviceCertificate other) {
      if (other == null) {
        return;
      }
      if (other.HasDeviceCertificate) {
        DeviceCertificate = other.DeviceCertificate;
      }
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      if (other.signer_ != null) {
        if (signer_ == null) {
          Signer = new global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate();
        }
        Signer.MergeFrom(other.Signer);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DeviceCertificate = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
          case 26: {
            if (signer_ == null) {
              Signer = new global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate();
            }
            input.ReadMessage(Signer);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DeviceCertificate = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
          case 26: {
            if (signer_ == null) {
              Signer = new global::AAXClean.Widevine.Provisioning.SignedDeviceCertificate();
            }
            input.ReadMessage(Signer);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Contains device model information for a provisioned device.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ProvisionedDeviceInfo : pb::IMessage<ProvisionedDeviceInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProvisionedDeviceInfo> _parser = new pb::MessageParser<ProvisionedDeviceInfo>(() => new ProvisionedDeviceInfo());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProvisionedDeviceInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisionedDeviceInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisionedDeviceInfo(ProvisionedDeviceInfo other) : this() {
      _hasBits0 = other._hasBits0;
      systemId_ = other.systemId_;
      soc_ = other.soc_;
      manufacturer_ = other.manufacturer_;
      model_ = other.model_;
      deviceType_ = other.deviceType_;
      modelYear_ = other.modelYear_;
      securityLevel_ = other.securityLevel_;
      testDevice_ = other.testDevice_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProvisionedDeviceInfo Clone() {
      return new ProvisionedDeviceInfo(this);
    }

    /// <summary>Field number for the "system_id" field.</summary>
    public const int SystemIdFieldNumber = 1;
    private readonly static uint SystemIdDefaultValue = 0;

    private uint systemId_;
    /// <summary>
    /// Widevine system ID for the device. Mandatory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint SystemId {
      get { if ((_hasBits0 & 1) != 0) { return systemId_; } else { return SystemIdDefaultValue; } }
      set {
        _hasBits0 |= 1;
        systemId_ = value;
      }
    }
    /// <summary>Gets whether the "system_id" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSystemId {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "system_id" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSystemId() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "soc" field.</summary>
    public const int SocFieldNumber = 2;
    private readonly static string SocDefaultValue = "";

    private string soc_;
    /// <summary>
    /// Name of system-on-a-chip. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Soc {
      get { return soc_ ?? SocDefaultValue; }
      set {
        soc_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "soc" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSoc {
      get { return soc_ != null; }
    }
    /// <summary>Clears the value of the "soc" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSoc() {
      soc_ = null;
    }

    /// <summary>Field number for the "manufacturer" field.</summary>
    public const int ManufacturerFieldNumber = 3;
    private readonly static string ManufacturerDefaultValue = "";

    private string manufacturer_;
    /// <summary>
    /// Name of manufacturer. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Manufacturer {
      get { return manufacturer_ ?? ManufacturerDefaultValue; }
      set {
        manufacturer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "manufacturer" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasManufacturer {
      get { return manufacturer_ != null; }
    }
    /// <summary>Clears the value of the "manufacturer" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearManufacturer() {
      manufacturer_ = null;
    }

    /// <summary>Field number for the "model" field.</summary>
    public const int ModelFieldNumber = 4;
    private readonly static string ModelDefaultValue = "";

    private string model_;
    /// <summary>
    /// Manufacturer's model name. Matches "brand" in device metadata. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Model {
      get { return model_ ?? ModelDefaultValue; }
      set {
        model_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "model" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasModel {
      get { return model_ != null; }
    }
    /// <summary>Clears the value of the "model" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearModel() {
      model_ = null;
    }

    /// <summary>Field number for the "device_type" field.</summary>
    public const int DeviceTypeFieldNumber = 5;
    private readonly static string DeviceTypeDefaultValue = "";

    private string deviceType_;
    /// <summary>
    /// Type of device (Phone, Tablet, TV, etc).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DeviceType {
      get { return deviceType_ ?? DeviceTypeDefaultValue; }
      set {
        deviceType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "device_type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDeviceType {
      get { return deviceType_ != null; }
    }
    /// <summary>Clears the value of the "device_type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDeviceType() {
      deviceType_ = null;
    }

    /// <summary>Field number for the "model_year" field.</summary>
    public const int ModelYearFieldNumber = 6;
    private readonly static uint ModelYearDefaultValue = 0;

    private uint modelYear_;
    /// <summary>
    /// Device model year. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint ModelYear {
      get { if ((_hasBits0 & 2) != 0) { return modelYear_; } else { return ModelYearDefaultValue; } }
      set {
        _hasBits0 |= 2;
        modelYear_ = value;
      }
    }
    /// <summary>Gets whether the "model_year" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasModelYear {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "model_year" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearModelYear() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "security_level" field.</summary>
    public const int SecurityLevelFieldNumber = 7;
    private readonly static global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel SecurityLevelDefaultValue = global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel.LevelUnspecified;

    private global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel securityLevel_;
    /// <summary>
    /// Widevine-defined security level. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel SecurityLevel {
      get { if ((_hasBits0 & 4) != 0) { return securityLevel_; } else { return SecurityLevelDefaultValue; } }
      set {
        _hasBits0 |= 4;
        securityLevel_ = value;
      }
    }
    /// <summary>Gets whether the "security_level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecurityLevel {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "security_level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecurityLevel() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "test_device" field.</summary>
    public const int TestDeviceFieldNumber = 8;
    private readonly static bool TestDeviceDefaultValue = false;

    private bool testDevice_;
    /// <summary>
    /// True if the certificate corresponds to a test (non production) device.
    /// Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool TestDevice {
      get { if ((_hasBits0 & 8) != 0) { return testDevice_; } else { return TestDeviceDefaultValue; } }
      set {
        _hasBits0 |= 8;
        testDevice_ = value;
      }
    }
    /// <summary>Gets whether the "test_device" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTestDevice {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "test_device" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTestDevice() {
      _hasBits0 &= ~8;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProvisionedDeviceInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProvisionedDeviceInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SystemId != other.SystemId) return false;
      if (Soc != other.Soc) return false;
      if (Manufacturer != other.Manufacturer) return false;
      if (Model != other.Model) return false;
      if (DeviceType != other.DeviceType) return false;
      if (ModelYear != other.ModelYear) return false;
      if (SecurityLevel != other.SecurityLevel) return false;
      if (TestDevice != other.TestDevice) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSystemId) hash ^= SystemId.GetHashCode();
      if (HasSoc) hash ^= Soc.GetHashCode();
      if (HasManufacturer) hash ^= Manufacturer.GetHashCode();
      if (HasModel) hash ^= Model.GetHashCode();
      if (HasDeviceType) hash ^= DeviceType.GetHashCode();
      if (HasModelYear) hash ^= ModelYear.GetHashCode();
      if (HasSecurityLevel) hash ^= SecurityLevel.GetHashCode();
      if (HasTestDevice) hash ^= TestDevice.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSystemId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SystemId);
      }
      if (HasSoc) {
        output.WriteRawTag(18);
        output.WriteString(Soc);
      }
      if (HasManufacturer) {
        output.WriteRawTag(26);
        output.WriteString(Manufacturer);
      }
      if (HasModel) {
        output.WriteRawTag(34);
        output.WriteString(Model);
      }
      if (HasDeviceType) {
        output.WriteRawTag(42);
        output.WriteString(DeviceType);
      }
      if (HasModelYear) {
        output.WriteRawTag(48);
        output.WriteUInt32(ModelYear);
      }
      if (HasSecurityLevel) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SecurityLevel);
      }
      if (HasTestDevice) {
        output.WriteRawTag(64);
        output.WriteBool(TestDevice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSystemId) {
        output.WriteRawTag(8);
        output.WriteUInt32(SystemId);
      }
      if (HasSoc) {
        output.WriteRawTag(18);
        output.WriteString(Soc);
      }
      if (HasManufacturer) {
        output.WriteRawTag(26);
        output.WriteString(Manufacturer);
      }
      if (HasModel) {
        output.WriteRawTag(34);
        output.WriteString(Model);
      }
      if (HasDeviceType) {
        output.WriteRawTag(42);
        output.WriteString(DeviceType);
      }
      if (HasModelYear) {
        output.WriteRawTag(48);
        output.WriteUInt32(ModelYear);
      }
      if (HasSecurityLevel) {
        output.WriteRawTag(56);
        output.WriteEnum((int) SecurityLevel);
      }
      if (HasTestDevice) {
        output.WriteRawTag(64);
        output.WriteBool(TestDevice);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSystemId) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(SystemId);
      }
      if (HasSoc) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Soc);
      }
      if (HasManufacturer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Manufacturer);
      }
      if (HasModel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Model);
      }
      if (HasDeviceType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DeviceType);
      }
      if (HasModelYear) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ModelYear);
      }
      if (HasSecurityLevel) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SecurityLevel);
      }
      if (HasTestDevice) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProvisionedDeviceInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasSystemId) {
        SystemId = other.SystemId;
      }
      if (other.HasSoc) {
        Soc = other.Soc;
      }
      if (other.HasManufacturer) {
        Manufacturer = other.Manufacturer;
      }
      if (other.HasModel) {
        Model = other.Model;
      }
      if (other.HasDeviceType) {
        DeviceType = other.DeviceType;
      }
      if (other.HasModelYear) {
        ModelYear = other.ModelYear;
      }
      if (other.HasSecurityLevel) {
        SecurityLevel = other.SecurityLevel;
      }
      if (other.HasTestDevice) {
        TestDevice = other.TestDevice;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            SystemId = input.ReadUInt32();
            break;
          }
          case 18: {
            Soc = input.ReadString();
            break;
          }
          case 26: {
            Manufacturer = input.ReadString();
            break;
          }
          case 34: {
            Model = input.ReadString();
            break;
          }
          case 42: {
            DeviceType = input.ReadString();
            break;
          }
          case 48: {
            ModelYear = input.ReadUInt32();
            break;
          }
          case 56: {
            SecurityLevel = (global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel) input.ReadEnum();
            break;
          }
          case 64: {
            TestDevice = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            SystemId = input.ReadUInt32();
            break;
          }
          case 18: {
            Soc = input.ReadString();
            break;
          }
          case 26: {
            Manufacturer = input.ReadString();
            break;
          }
          case 34: {
            Model = input.ReadString();
            break;
          }
          case 42: {
            DeviceType = input.ReadString();
            break;
          }
          case 48: {
            ModelYear = input.ReadUInt32();
            break;
          }
          case 56: {
            SecurityLevel = (global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo.Types.WvSecurityLevel) input.ReadEnum();
            break;
          }
          case 64: {
            TestDevice = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ProvisionedDeviceInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum WvSecurityLevel {
        /// <summary>
        /// Defined in "WV Modular DRM Security Integration Guide for
        /// Common Encryption (CENC)"
        /// </summary>
        [pbr::OriginalName("LEVEL_UNSPECIFIED")] LevelUnspecified = 0,
        [pbr::OriginalName("LEVEL_1")] Level1 = 1,
        [pbr::OriginalName("LEVEL_2")] Level2 = 2,
        [pbr::OriginalName("LEVEL_3")] Level3 = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Contains the status of the root or an intermediate DeviceCertificate.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DeviceCertificateStatus : pb::IMessage<DeviceCertificateStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeviceCertificateStatus> _parser = new pb::MessageParser<DeviceCertificateStatus>(() => new DeviceCertificateStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DeviceCertificateStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatus(DeviceCertificateStatus other) : this() {
      _hasBits0 = other._hasBits0;
      serialNumber_ = other.serialNumber_;
      status_ = other.status_;
      deviceInfo_ = other.deviceInfo_ != null ? other.deviceInfo_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatus Clone() {
      return new DeviceCertificateStatus(this);
    }

    /// <summary>Field number for the "serial_number" field.</summary>
    public const int SerialNumberFieldNumber = 1;
    private readonly static pb::ByteString SerialNumberDefaultValue = pb::ByteString.Empty;

    private pb::ByteString serialNumber_;
    /// <summary>
    /// Serial number of the DeviceCertificate to which this message refers.
    /// Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SerialNumber {
      get { return serialNumber_ ?? SerialNumberDefaultValue; }
      set {
        serialNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "serial_number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSerialNumber {
      get { return serialNumber_ != null; }
    }
    /// <summary>Clears the value of the "serial_number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSerialNumber() {
      serialNumber_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus StatusDefaultValue = global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus.Valid;

    private global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus status_;
    /// <summary>
    /// Status of the certificate. Optional.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus Status {
      get { if ((_hasBits0 & 1) != 0) { return status_; } else { return StatusDefaultValue; } }
      set {
        _hasBits0 |= 1;
        status_ = value;
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "device_info" field.</summary>
    public const int DeviceInfoFieldNumber = 4;
    private global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo deviceInfo_;
    /// <summary>
    /// Device model information about the device to which the certificate
    /// corresponds. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo DeviceInfo {
      get { return deviceInfo_; }
      set {
        deviceInfo_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DeviceCertificateStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DeviceCertificateStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SerialNumber != other.SerialNumber) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(DeviceInfo, other.DeviceInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSerialNumber) hash ^= SerialNumber.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (deviceInfo_ != null) hash ^= DeviceInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSerialNumber) {
        output.WriteRawTag(10);
        output.WriteBytes(SerialNumber);
      }
      if (HasStatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Status);
      }
      if (deviceInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DeviceInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSerialNumber) {
        output.WriteRawTag(10);
        output.WriteBytes(SerialNumber);
      }
      if (HasStatus) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Status);
      }
      if (deviceInfo_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DeviceInfo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSerialNumber) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SerialNumber);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Status);
      }
      if (deviceInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeviceInfo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DeviceCertificateStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasSerialNumber) {
        SerialNumber = other.SerialNumber;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.deviceInfo_ != null) {
        if (deviceInfo_ == null) {
          DeviceInfo = new global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo();
        }
        DeviceInfo.MergeFrom(other.DeviceInfo);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SerialNumber = input.ReadBytes();
            break;
          }
          case 16: {
            Status = (global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus) input.ReadEnum();
            break;
          }
          case 34: {
            if (deviceInfo_ == null) {
              DeviceInfo = new global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo();
            }
            input.ReadMessage(DeviceInfo);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SerialNumber = input.ReadBytes();
            break;
          }
          case 16: {
            Status = (global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Types.CertificateStatus) input.ReadEnum();
            break;
          }
          case 34: {
            if (deviceInfo_ == null) {
              DeviceInfo = new global::AAXClean.Widevine.Provisioning.ProvisionedDeviceInfo();
            }
            input.ReadMessage(DeviceInfo);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the DeviceCertificateStatus message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      public enum CertificateStatus {
        [pbr::OriginalName("VALID")] Valid = 0,
        [pbr::OriginalName("REVOKED")] Revoked = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// List of DeviceCertificateStatus. Used to propagate certificate revocation and
  /// update list.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class DeviceCertificateStatusList : pb::IMessage<DeviceCertificateStatusList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DeviceCertificateStatusList> _parser = new pb::MessageParser<DeviceCertificateStatusList>(() => new DeviceCertificateStatusList());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DeviceCertificateStatusList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatusList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatusList(DeviceCertificateStatusList other) : this() {
      _hasBits0 = other._hasBits0;
      creationTimeSeconds_ = other.creationTimeSeconds_;
      certificateStatus_ = other.certificateStatus_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DeviceCertificateStatusList Clone() {
      return new DeviceCertificateStatusList(this);
    }

    /// <summary>Field number for the "creation_time_seconds" field.</summary>
    public const int CreationTimeSecondsFieldNumber = 1;
    private readonly static uint CreationTimeSecondsDefaultValue = 0;

    private uint creationTimeSeconds_;
    /// <summary>
    /// POSIX time, in seconds, when the list was created. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint CreationTimeSeconds {
      get { if ((_hasBits0 & 1) != 0) { return creationTimeSeconds_; } else { return CreationTimeSecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        creationTimeSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "creation_time_seconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCreationTimeSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "creation_time_seconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCreationTimeSeconds() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "certificate_status" field.</summary>
    public const int CertificateStatusFieldNumber = 2;
    private static readonly pb::FieldCodec<global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus> _repeated_certificateStatus_codec
        = pb::FieldCodec.ForMessage(18, global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus.Parser);
    private readonly pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus> certificateStatus_ = new pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus>();
    /// <summary>
    /// DeviceCertificateStatus for each certifificate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::AAXClean.Widevine.Provisioning.DeviceCertificateStatus> CertificateStatus {
      get { return certificateStatus_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DeviceCertificateStatusList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DeviceCertificateStatusList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CreationTimeSeconds != other.CreationTimeSeconds) return false;
      if(!certificateStatus_.Equals(other.certificateStatus_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCreationTimeSeconds) hash ^= CreationTimeSeconds.GetHashCode();
      hash ^= certificateStatus_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCreationTimeSeconds) {
        output.WriteRawTag(8);
        output.WriteUInt32(CreationTimeSeconds);
      }
      certificateStatus_.WriteTo(output, _repeated_certificateStatus_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCreationTimeSeconds) {
        output.WriteRawTag(8);
        output.WriteUInt32(CreationTimeSeconds);
      }
      certificateStatus_.WriteTo(ref output, _repeated_certificateStatus_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCreationTimeSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(CreationTimeSeconds);
      }
      size += certificateStatus_.CalculateSize(_repeated_certificateStatus_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DeviceCertificateStatusList other) {
      if (other == null) {
        return;
      }
      if (other.HasCreationTimeSeconds) {
        CreationTimeSeconds = other.CreationTimeSeconds;
      }
      certificateStatus_.Add(other.certificateStatus_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CreationTimeSeconds = input.ReadUInt32();
            break;
          }
          case 18: {
            certificateStatus_.AddEntriesFrom(input, _repeated_certificateStatus_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            CreationTimeSeconds = input.ReadUInt32();
            break;
          }
          case 18: {
            certificateStatus_.AddEntriesFrom(ref input, _repeated_certificateStatus_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Signed CertificateStatusList
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SignedCertificateStatusList : pb::IMessage<SignedCertificateStatusList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SignedCertificateStatusList> _parser = new pb::MessageParser<SignedCertificateStatusList>(() => new SignedCertificateStatusList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SignedCertificateStatusList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AAXClean.Widevine.Provisioning.LicenseProtocolReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedCertificateStatusList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedCertificateStatusList(SignedCertificateStatusList other) : this() {
      certificateStatusList_ = other.certificateStatusList_;
      signature_ = other.signature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SignedCertificateStatusList Clone() {
      return new SignedCertificateStatusList(this);
    }

    /// <summary>Field number for the "certificate_status_list" field.</summary>
    public const int CertificateStatusListFieldNumber = 1;
    private readonly static pb::ByteString CertificateStatusListDefaultValue = pb::ByteString.Empty;

    private pb::ByteString certificateStatusList_;
    /// <summary>
    /// Serialized DeviceCertificateStatusList. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString CertificateStatusList {
      get { return certificateStatusList_ ?? CertificateStatusListDefaultValue; }
      set {
        certificateStatusList_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "certificate_status_list" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCertificateStatusList {
      get { return certificateStatusList_ != null; }
    }
    /// <summary>Clears the value of the "certificate_status_list" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCertificateStatusList() {
      certificateStatusList_ = null;
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private readonly static pb::ByteString SignatureDefaultValue = pb::ByteString.Empty;

    private pb::ByteString signature_;
    /// <summary>
    /// Signature of certificate_status_list. Signed with root certificate private
    /// key using RSASSA-PSS. Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Signature {
      get { return signature_ ?? SignatureDefaultValue; }
      set {
        signature_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "signature" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignature {
      get { return signature_ != null; }
    }
    /// <summary>Clears the value of the "signature" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignature() {
      signature_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SignedCertificateStatusList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SignedCertificateStatusList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CertificateStatusList != other.CertificateStatusList) return false;
      if (Signature != other.Signature) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCertificateStatusList) hash ^= CertificateStatusList.GetHashCode();
      if (HasSignature) hash ^= Signature.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCertificateStatusList) {
        output.WriteRawTag(10);
        output.WriteBytes(CertificateStatusList);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCertificateStatusList) {
        output.WriteRawTag(10);
        output.WriteBytes(CertificateStatusList);
      }
      if (HasSignature) {
        output.WriteRawTag(18);
        output.WriteBytes(Signature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCertificateStatusList) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(CertificateStatusList);
      }
      if (HasSignature) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Signature);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SignedCertificateStatusList other) {
      if (other == null) {
        return;
      }
      if (other.HasCertificateStatusList) {
        CertificateStatusList = other.CertificateStatusList;
      }
      if (other.HasSignature) {
        Signature = other.Signature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CertificateStatusList = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CertificateStatusList = input.ReadBytes();
            break;
          }
          case 18: {
            Signature = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
